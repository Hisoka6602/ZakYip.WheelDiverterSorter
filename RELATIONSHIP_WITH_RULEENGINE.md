# ZakYip系统架构关系文档

## 概述

本文档详细说明了 **ZakYip.WheelDiverterSorter（摆轮分拣系统）** 和 **ZakYip.Sorting.RuleEngine.Core（分拣规则引擎）** 两个系统之间的关系。这两个系统构成了一个完整的智能包裹分拣解决方案，互为上下游关系。

---

## 系统定位

### 上游系统：ZakYip.Sorting.RuleEngine.Core（规则引擎）
**GitHub**: https://github.com/Hisoka6602/ZakYip.Sorting.RuleEngine.Core

**核心职责：**
- 📋 **决策层** - 根据包裹信息和规则决定包裹应该去哪个格口
- 🧠 **智能分析** - 使用规则引擎评估包裹属性（条码、重量、尺寸、OCR、API响应）
- 📊 **数据处理** - 接收并处理DWS（尺寸重量扫描）数据
- 🔌 **第三方集成** - 调用外部API（邮政、ERP、WMS等）获取格口信息
- 📝 **日志记录** - 记录包裹处理过程的所有数据

**系统特点：**
- 完成度：约 87%
- 架构模式：事件驱动架构（Event-Driven）+ CQRS
- 支持协议：SignalR、TCP、MQTT、HTTP
- 数据库：LiteDB（配置）+ MySQL（日志）+ SQLite（降级）
- 技术栈：.NET 8.0 + ASP.NET Core

### 下游系统：ZakYip.WheelDiverterSorter（摆轮分拣系统）
**GitHub**: https://github.com/Hisoka6602/ZakYip.WheelDiverterSorter

**核心职责：**
- ⚙️ **执行层** - 根据格口号生成摆轮路径并控制摆轮动作
- 🎯 **路径规划** - 将格口号转换为一系列摆轮动作指令
- 🔄 **设备控制** - 执行摆轮路径，控制摆轮角度
- 📍 **拓扑管理** - 管理摆轮节点和格口的物理拓扑结构
- ⏱️ **时序控制** - 管理包裹经过每个摆轮的时间窗口（TTL）

**系统特点：**
- 完成度：约 70%（核心功能100%，生产功能部分完成）
- 架构模式：分层架构 + 依赖注入
- 支持格口：动态配置（LiteDB存储）
- 技术栈：.NET 8.0 + ASP.NET Core Minimal API
- 特性：热更新配置、模拟执行器、调试接口

---

## 上下游关系图

```
┌─────────────────────────────────────────────────────────────────────┐
│                        包裹分拣完整流程                              │
└─────────────────────────────────────────────────────────────────────┘

    ┌────────────┐
    │  DWS设备   │ ── 测量数据 (重量/尺寸/条码)
    └──────┬─────┘
           │
           ▼
┌──────────────────────────────────────────────────────────────┐
│         上游：ZakYip.Sorting.RuleEngine.Core                  │
├──────────────────────────────────────────────────────────────┤
│  1. 接收DWS数据                                              │
│     ├─ 条码                                                  │
│     ├─ 重量                                                  │
│     ├─ 长宽高                                                │
│     └─ 体积                                                  │
│                                                              │
│  2. 调用第三方API - 可选                                     │
│     ├─ 邮政API                                               │
│     ├─ 聚水潭ERP                                             │
│     ├─ 旺店通WMS                                             │
│     └─ 旺店通ERP旗舰版                                       │
│                                                              │
│  3. 规则引擎评估                                             │
│     ├─ 条码正则匹配                                          │
│     ├─ 重量范围匹配                                          │
│     ├─ 体积尺寸匹配                                          │
│     ├─ OCR识别匹配                                           │
│     ├─ API响应匹配                                           │
│     └─ 低代码表达式                                          │
│                                                              │
│  4. 输出格口号                                               │
│     └─ ChuteNumber: "CHUTE_A", "CHUTE_B", etc.              │
└──────────────────┬───────────────────────────────────────────┘
                   │
                   │ ✉️ 传递格口号
                   ▼
┌──────────────────────────────────────────────────────────────┐
│        下游：ZakYip.WheelDiverterSorter                       │
├──────────────────────────────────────────────────────────────┤
│  5. 接收格口号                                               │
│     └─ 输入: ParcelId + TargetChuteId                        │
│                                                              │
│  6. 生成摆轮路径                                             │
│     └─ ISwitchingPathGenerator                              │
│        ├─ 查询格口到摆轮映射                                 │
│        └─ 生成路径段列表                                     │
│           示例：                                             │
│           CHUTE_A → [D1:30°, D2:45°]                        │
│           CHUTE_B → [D1:0°]                                 │
│           CHUTE_C → [D1:90°, D3:30°]                        │
│                                                              │
│  7. 执行摆轮路径                                             │
│     └─ ISwitchingPathExecutor                               │
│        ├─ 按顺序执行每个路径段                               │
│        ├─ 控制摆轮角度                                       │
│        ├─ 监控TTL超时                                        │
│        └─ 模拟执行器 / 真实设备通信                          │
│                                                              │
│  8. 返回执行结果                                             │
│     ├─ 成功: actualChuteId = targetChuteId                   │
│     └─ 失败: actualChuteId = "CHUTE_EXCEPTION"               │
└──────────────────┬───────────────────────────────────────────┘
                   │
                   ▼
           ┌────────────┐
           │  包裹到达   │
           │  目标格口   │
           └────────────┘
```

---

## 详细交互流程

### 阶段1：规则引擎决策（上游）

```
步骤1: 分拣机发送包裹创建信号
→ ParcelId: "PKG001"
→ CartNumber: 12345

步骤2: DWS设备发送测量数据
→ Barcode: "1234567890"
→ Weight: 1500g
→ Length: 30cm, Width: 20cm, Height: 15cm
→ Volume: 9000cm³

步骤3: 规则引擎处理
→ 调用第三方API（可选）
→ 评估规则（6种匹配方法）
→ 选择优先级最高的匹配规则

步骤4: 输出格口号
→ ChuteNumber: "CHUTE_A"
```

### 阶段2：摆轮执行（下游）

```
步骤5: 摆轮系统接收格口号
→ ParcelId: "PKG001"
→ TargetChuteId: "CHUTE_A"

步骤6: 生成摆轮路径
→ 查询配置数据库（LiteDB）
→ 格口A的映射：
  [
    { DiverterId: "D1", TargetAngle: 30, TTL: 5000ms },
    { DiverterId: "D2", TargetAngle: 45, TTL: 5000ms }
  ]

步骤7: 执行路径段
→ 段1: 摆轮D1旋转到30°，等待包裹通过
→ 段2: 摆轮D2旋转到45°，等待包裹通过

步骤8: 返回结果
→ Success: true
→ ActualChuteId: "CHUTE_A"
→ Message: "分拣成功"
```

---

## 数据流向

### 从上游到下游

| 数据项 | 来源 | 去向 | 说明 |
|-------|-----|-----|-----|
| ParcelId | 分拣机 → 规则引擎 | 规则引擎 → 摆轮系统 | 包裹唯一标识符 |
| ChuteNumber | 规则引擎决策输出 | 摆轮系统输入 | 目标格口号 |
| Barcode | DWS → 规则引擎 | （不传递） | 仅用于规则匹配 |
| Weight/Size | DWS → 规则引擎 | （不传递） | 仅用于规则匹配 |

### 关键集成点

**当前状态：**
- ❌ **尚未直接集成**
- 两个系统可以独立运行和测试
- 需要中间层或适配器连接

**推荐集成方式：**

#### 方式1：REST API集成
```
规则引擎 → HTTP POST → 摆轮系统

POST http://wheeldiverter:5000/api/debug/sort
{
  "parcelId": "PKG001",
  "targetChuteId": "CHUTE_A"
}
```

**优点：**
- ✅ 简单易实现
- ✅ 松耦合
- ✅ 支持HTTP标准

**缺点：**
- ⚠️ 同步调用，可能阻塞
- ⚠️ 需要处理HTTP超时和重试

#### 方式2：消息队列集成
```
规则引擎 → RabbitMQ/Kafka → 摆轮系统

Topic: "sorting.chute.assignment"
Message: { parcelId, chuteNumber, timestamp }
```

**优点：**
- ✅ 异步解耦
- ✅ 高可靠性，支持重试
- ✅ 可扩展性强

**缺点：**
- ⚠️ 需要额外的消息队列服务
- ⚠️ 复杂度增加

#### 方式3：SignalR实时通信
```
规则引擎 → SignalR Hub → 摆轮系统

Hub Method: "AssignParcelToChute"
Parameters: { parcelId, chuteNumber }
```

**优点：**
- ✅ 实时双向通信
- ✅ 规则引擎已支持SignalR
- ✅ 自动重连机制

**缺点：**
- ⚠️ 摆轮系统需要实现SignalR客户端
- ⚠️ 需要维持长连接

---

## 系统对比

| 特性 | 规则引擎 | 摆轮系统 |
|-----|---------|---------|
| **定位** | 上游决策层 | 下游执行层 |
| **核心功能** | 决定去哪个格口 | 如何到达格口 |
| **完成度** | 87% | 70% |
| **架构模式** | 事件驱动 + CQRS | 分层架构 |
| **数据库** | LiteDB + MySQL + SQLite | LiteDB |
| **通信协议** | SignalR, TCP, MQTT, HTTP | HTTP (调试) |
| **外部集成** | 6种第三方API | 无 |
| **规则引擎** | 6种匹配方法 | 无 |
| **路径规划** | 无 | 摆轮路径生成 |
| **设备控制** | 无 | 摆轮角度控制 |
| **测试工具** | DataSimulator, InterfaceSimulator | 调试API |
| **单元测试** | 310+ | 无 |
| **热更新** | 规则配置热更新 | 格口配置热更新 |

---

## 配合使用场景

### 场景1：标准包裹分拣流程

```
1. DWS扫描包裹 → 规则引擎
   
2. 规则引擎决定格口A → 摆轮系统
   
3. 摆轮系统生成路径 [D1:30°, D2:45°] → 执行
   
4. 包裹成功到达格口A
```

### 场景2：异常包裹处理

```
1. DWS扫描异常包裹 → 规则引擎
   
2. 规则引擎无匹配规则 → 返回异常格口 "CHUTE_EXCEPTION"
   
3. 摆轮系统生成异常口路径 → 执行
   
4. 包裹到达异常格口等待人工处理
```

### 场景3：高并发批量处理

```
1. 规则引擎FIFO队列接收1000个包裹
   
2. 并发评估规则并输出格口号
   
3. 摆轮系统接收格口号批次
   
4. 按序执行摆轮路径（保持顺序）
```

---

## 部署架构建议

### 单机部署

```
┌─────────────────────────────────────────┐
│         服务器                           │
│                                         │
│  ┌───────────────────────────────┐    │
│  │  规则引擎服务 :5000            │    │
│  └───────────┬───────────────────┘    │
│              │ HTTP/SignalR            │
│  ┌───────────▼───────────────────┐    │
│  │  摆轮系统服务 :5001            │    │
│  └───────────────────────────────┘    │
│                                         │
│  ┌───────────────────────────────┐    │
│  │  MySQL数据库 :3306             │    │
│  └───────────────────────────────┘    │
└─────────────────────────────────────────┘
```

**适用场景：**
- 小规模部署（<100包裹/分钟）
- 开发和测试环境

### 分布式部署

```
┌───────────────────┐    ┌───────────────────┐
│  规则引擎集群      │    │  摆轮系统集群      │
│                   │    │                   │
│  ┌─────┐ ┌─────┐ │    │  ┌─────┐ ┌─────┐ │
│  │ RE1 │ │ RE2 │ │    │  │ WD1 │ │ WD2 │ │
│  └─────┘ └─────┘ │    │  └─────┘ └─────┘ │
└────────┬──────────┘    └────────┬──────────┘
         │                        │
         └────────┬───────────────┘
                  │
         ┌────────▼─────────┐
         │  消息队列         │
         │  (RabbitMQ)      │
         └──────────────────┘
                  │
         ┌────────▼─────────┐
         │  MySQL主从集群   │
         └──────────────────┘
```

**适用场景：**
- 大规模生产环境（500-1000包裹/秒）
- 高可用性要求

---

## 未来集成路线图

### 第1阶段：适配器开发（1-2周）

- [ ] 在规则引擎中添加摆轮系统客户端
- [ ] 实现HTTP API调用
- [ ] 添加错误处理和重试机制
- [ ] 单元测试覆盖

### 第2阶段：消息队列集成（2-4周）

- [ ] 引入RabbitMQ或Kafka
- [ ] 规则引擎发布格口分配消息
- [ ] 摆轮系统订阅并处理消息
- [ ] 实现消息确认和重试

### 第3阶段：性能优化（持续）

- [ ] 批量处理优化
- [ ] 并发控制和队列管理
- [ ] 监控和告警集成
- [ ] 压力测试（1000包裹/秒）

### 第4阶段：统一管理平台（3-6个月）

- [ ] 开发Web管理界面
- [ ] 统一配置管理
- [ ] 统一日志查询
- [ ] 实时监控仪表板

---

## 技术栈兼容性

| 技术 | 规则引擎 | 摆轮系统 | 兼容性 |
|-----|---------|---------|--------|
| .NET版本 | .NET 8.0 | .NET 8.0 | ✅ 完全兼容 |
| Web框架 | ASP.NET Core | ASP.NET Core Minimal API | ✅ 完全兼容 |
| 依赖注入 | ✅ | ✅ | ✅ 完全兼容 |
| SignalR | ✅ | ❌ | ⚠️ 需要添加 |
| TCP通信 | ✅ (TouchSocket) | ❌ | ⚠️ 需要添加 |
| MQTT | ✅ (MQTTnet) | ❌ | ⚠️ 需要添加 |
| LiteDB | ✅ | ✅ | ✅ 完全兼容 |
| MySQL | ✅ | ❌ | ⚠️ 可选 |
| 配置热更新 | ✅ | ✅ | ✅ 完全兼容 |

---

## 常见问题

### Q1: 两个系统必须同时使用吗？

**答：** 
不是必须的。两个系统可以独立运行和测试：

- 规则引擎可以单独运行，用于格口决策和数据分析
- 摆轮系统可以通过调试API手动测试分拣路径

但在生产环境中，它们应该集成使用以实现完整的自动分拣流程。

### Q2: 如何保证数据一致性？

**答：**
- 使用消息队列确保可靠传递
- 实现幂等性保护，避免重复处理
- 添加事务日志，支持数据追溯
- 定期对账和数据同步

### Q3: 性能瓶颈在哪里？

**答：**
- 规则引擎：规则评估（已优化到50ms P99延迟）
- 摆轮系统：路径生成和执行（取决于物理设备速度）
- 网络通信：如果使用HTTP，建议改用SignalR或消息队列

### Q4: 支持多少并发？

**答：**
- 规则引擎：支持1000包裹/秒（单实例）
- 摆轮系统：取决于摆轮设备数量和响应速度
- 集成后：建议使用消息队列和负载均衡，理论上可支持10000+包裹/秒

### Q5: 如何处理异常情况？

**答：**
- 规则引擎：无匹配规则时返回异常格口
- 摆轮系统：路径执行失败时返回异常格口
- 集成层：添加错误重试和降级策略
- 监控告警：实时监控异常率并告警

---

## 联系方式

**规则引擎项目：**
- GitHub: https://github.com/Hisoka6602/ZakYip.Sorting.RuleEngine.Core
- Issues: https://github.com/Hisoka6602/ZakYip.Sorting.RuleEngine.Core/issues

**摆轮系统项目：**
- GitHub: https://github.com/Hisoka6602/ZakYip.WheelDiverterSorter
- Issues: https://github.com/Hisoka6602/ZakYip.WheelDiverterSorter/issues

---

## 总结

✅ **成功访问了 ZakYip.Sorting.RuleEngine.Core 仓库**

✅ **两个系统互为上下游关系：**
   - **规则引擎（上游）**: 决定包裹去哪个格口
   - **摆轮系统（下游）**: 控制摆轮将包裹送到指定格口

✅ **当前状态：尚未直接集成，但架构兼容，可通过HTTP API、消息队列或SignalR集成**

✅ **两个系统都具备良好的可扩展性和完整的文档**

📝 **本文档提供了详细的集成方案和路线图**

---

**文档版本：** 1.0  
**创建日期：** 2025-11-12  
**最后更新：** 2025-11-12
