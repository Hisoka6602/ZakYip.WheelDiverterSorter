# ZakYip系统架构关系文档

## 概述

本文档详细说明了 **ZakYip.WheelDiverterSorter（摆轮分拣系统）** 和 **ZakYip.Sorting.RuleEngine.Core（分拣规则引擎）** 两个系统之间的关系。

**重要说明：**
- 这两个系统是**分开部署**的独立程序，互为上下游关系
- 它们通过网络通信协议进行数据交互，而非直接集成
- 可以独立启动、停止和维护，互不影响对方的运行

---

## 系统定位

### 上游系统：ZakYip.Sorting.RuleEngine.Core（规则引擎）
**GitHub**: https://github.com/Hisoka6602/ZakYip.Sorting.RuleEngine.Core

**核心职责：**
- 📋 **决策层** - 根据包裹信息和规则决定包裹应该去哪个格口
- 🧠 **智能分析** - 使用规则引擎评估包裹属性（条码、重量、尺寸、OCR、API响应）
- 📊 **数据处理** - 接收并处理DWS（尺寸重量扫描）数据
- 🔌 **第三方集成** - 调用外部API（邮政、ERP、WMS等）获取格口信息
- 📝 **日志记录** - 记录包裹处理过程的所有数据

**系统特点：**
- 完成度：约 87%
- 架构模式：事件驱动架构（Event-Driven）+ CQRS
- 支持协议：SignalR、TCP、MQTT、HTTP
- 数据库：LiteDB（配置）+ MySQL（日志）+ SQLite（降级）
- 技术栈：.NET 8.0 + ASP.NET Core

### 下游系统：ZakYip.WheelDiverterSorter（摆轮分拣系统）
**GitHub**: https://github.com/Hisoka6602/ZakYip.WheelDiverterSorter

**核心职责：**
- 📦 **包裹创建** - 通过IO传感器感应物理包裹，在系统中创建包裹记录
- ⚙️ **执行层** - 根据格口号生成摆轮路径并控制摆轮动作
- 🎯 **路径规划** - 将格口号转换为一系列摆轮动作指令
- 🔄 **设备控制** - 执行摆轮路径，控制摆轮角度
- 📍 **拓扑管理** - 管理摆轮节点和格口的物理拓扑结构
- ⏱️ **时序控制** - 管理包裹经过每个摆轮的时间窗口（TTL）
- 🚀 **实际分拣** - 负责物理分拣动作的实际执行

**系统特点：**
- 完成度：约 70%（核心功能100%，生产功能部分完成）
- 架构模式：分层架构 + 依赖注入
- 支持格口：动态配置（LiteDB存储）
- 技术栈：.NET 8.0 + ASP.NET Core Minimal API
- 特性：热更新配置、模拟执行器、调试接口

---

## 部署模型与通信方式

### 分开部署架构

两个系统必须**分开部署**，各自独立运行：

```
┌─────────────────────────────────────────────────────────────────┐
│                        物理部署架构                              │
└─────────────────────────────────────────────────────────────────┘

    服务器A (或容器A)               服务器B (或容器B)
┌────────────────────────┐    ┌────────────────────────┐
│  RuleEngine.Core       │    │  WheelDiverterSorter   │
│  端口: 5000            │◄───┤  端口: 5001            │
│                        │    │                        │
│  - 规则引擎            │    │  - IO传感器监听        │
│  - DWS API集成         │    │  - 包裹创建            │
│  - 格口决策            │    │  - 摆轮路径生成        │
│  - 数据库：MySQL       │    │  - 摆轮控制执行        │
│  - 配置：LiteDB        │    │  - 数据库：LiteDB      │
└────────────────────────┘    └────────────────────────┘
         ▲                              │
         │                              │
         │    ③ 发送包裹ID请求格口号     │
         └──────────────────────────────┘
         
         ① WheelDiverterSorter: IO传感器检测包裹
         ② WheelDiverterSorter: 创建包裹记录
         ③ WheelDiverterSorter: 向RuleEngine请求格口号
         ④ RuleEngine: 与DWS第三方API通信获取包裹信息
         ⑤ RuleEngine: 返回格口号给WheelDiverterSorter
         ⑥ WheelDiverterSorter: 执行实际分拣动作
```

### 通信协议选择

两个系统支持**多种通信方式**（多选一）：

| 通信方式 | 适用场景 | 生产环境 | 说明 |
|---------|---------|---------|------|
| **TCP** | 高性能生产环境 | ✅ **推荐** | 低延迟、高吞吐量，适合实时控制 |
| **SignalR** | 实时双向通信 | ✅ **推荐** | 支持自动重连，适合长连接场景 |
| **MQTT** | IoT设备集成 | ✅ **推荐** | 轻量级消息协议，适合嵌入式设备 |
| **HTTP** | 开发测试环境 | ❌ **禁止** | 仅用于模拟测试，生产环境禁用 |

**生产环境通信方式建议：**

#### 方式1：TCP Socket 通信（推荐）
```
WheelDiverterSorter → TCP客户端 → RuleEngine TCP服务器

优点：
✅ 低延迟（<10ms）
✅ 高吞吐量
✅ 长连接，减少握手开销
✅ 适合实时控制场景

配置示例：
{
  "CommunicationMode": "TCP",
  "RuleEngineServer": "192.168.1.100:8000"
}
```

#### 方式2：SignalR 实时通信（推荐）
```
WheelDiverterSorter → SignalR客户端 → RuleEngine SignalR Hub

优点：
✅ 实时双向通信
✅ 自动重连机制
✅ 支持组播和广播
✅ RuleEngine已内置支持

配置示例：
{
  "CommunicationMode": "SignalR",
  "RuleEngineHub": "http://192.168.1.100:5000/sortingHub"
}
```

#### 方式3：MQTT 消息队列（推荐）
```
WheelDiverterSorter ←→ MQTT Broker ←→ RuleEngine

优点：
✅ 解耦性强
✅ 支持消息持久化
✅ 适合多节点部署
✅ QoS质量保证

配置示例：
{
  "CommunicationMode": "MQTT",
  "MqttBroker": "mqtt://192.168.1.100:1883",
  "MqttTopic": "sorting/chute/assignment"
}
```

#### 方式4：HTTP REST API（仅测试用）
```
WheelDiverterSorter → HTTP POST → RuleEngine API

⚠️ 警告：
❌ 生产环境禁止使用
❌ 同步阻塞调用
❌ 性能较差
✅ 仅用于开发调试和模拟测试

配置示例（仅开发环境）：
{
  "CommunicationMode": "HTTP",
  "RuleEngineApi": "http://localhost:5000/api/sorting/chute"
}
```

**为什么生产环境禁止使用HTTP？**
1. **同步阻塞**：每次请求都需要等待响应，降低吞吐量
2. **连接开销**：频繁建立/销毁TCP连接，浪费资源
3. **无重连机制**：网络抖动时容易失败，需要手动处理
4. **性能瓶颈**：HTTP协议头开销大，不适合高频通信

---

## 上下游关系图

```
┌─────────────────────────────────────────────────────────────────────┐
│                        包裹分拣完整流程                              │
└─────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────┐
│        下游：ZakYip.WheelDiverterSorter（独立部署）            │
├──────────────────────────────────────────────────────────────┤
│  步骤1: IO传感器感应包裹                                     │
│     └─ 物理传感器检测到包裹到达                              │
│                                                              │
│  步骤2: 创建包裹记录                                         │
│     └─ 在本地系统中创建包裹对象                              │
│        └─ ParcelId: 系统生成唯一ID                           │
└──────────────────┬───────────────────────────────────────────┘
                   │
                   │ 🔗 通过TCP/SignalR/MQTT发送包裹ID
                   ▼
┌──────────────────────────────────────────────────────────────┐
│         上游：ZakYip.Sorting.RuleEngine.Core（独立部署）      │
├──────────────────────────────────────────────────────────────┤
│  步骤3: 接收包裹ID，与DWS第三方API通信                       │
│     ├─ 根据包裹ID查询DWS系统                                 │
│     ├─ 获取条码/重量/尺寸等数据                              │
│     └─ DWS API响应包裹详细信息                               │
│                                                              │
│  步骤4: 调用其他第三方API（可选）                            │
│     ├─ 邮政API                                               │
│     ├─ 聚水潭ERP                                             │
│     ├─ 旺店通WMS                                             │
│     └─ 旺店通ERP旗舰版                                       │
│                                                              │
│  步骤5: 规则引擎评估                                         │
│     ├─ 条码正则匹配                                          │
│     ├─ 重量范围匹配                                          │
│     ├─ 体积尺寸匹配                                          │
│     ├─ OCR识别匹配                                           │
│     ├─ API响应匹配                                           │
│     └─ 低代码表达式                                          │
│                                                              │
│  步骤6: 输出格口号                                           │
│     └─ ChuteNumber: "CHUTE_A", "CHUTE_B", etc.              │
└──────────────────┬───────────────────────────────────────────┘
                   │
                   │ 🔗 通过TCP/SignalR/MQTT返回格口号
                   ▼
┌──────────────────────────────────────────────────────────────┐
│        下游：ZakYip.WheelDiverterSorter（独立部署）            │
├──────────────────────────────────────────────────────────────┤
│  步骤7: 接收格口号                                           │
│     └─ 输入: ParcelId + TargetChuteId                        │
│                                                              │
│  步骤8: 生成摆轮路径                                         │
│     └─ ISwitchingPathGenerator                              │
│        ├─ 查询格口到摆轮映射                                 │
│        └─ 生成路径段列表                                     │
│           示例：                                             │
│           CHUTE_A → [D1:30°, D2:45°]                        │
│           CHUTE_B → [D1:0°]                                 │
│           CHUTE_C → [D1:90°, D3:30°]                        │
│                                                              │
│  步骤9: 执行摆轮路径（实际分拣动作）                         │
│     └─ ISwitchingPathExecutor                               │
│        ├─ 按顺序执行每个路径段                               │
│        ├─ 控制摆轮角度                                       │
│        ├─ 监控TTL超时                                        │
│        └─ 模拟执行器 / 真实设备通信                          │
│                                                              │
│  步骤10: 返回执行结果                                        │
│     ├─ 成功: actualChuteId = targetChuteId                   │
│     └─ 失败: actualChuteId = "CHUTE_EXCEPTION"               │
└──────────────────┬───────────────────────────────────────────┘
                   │
                   ▼
           ┌────────────┐
           │  包裹到达   │
           │  目标格口   │
           └────────────┘
```

---

## 详细交互流程

### 阶段1：包裹感应与创建（WheelDiverterSorter）

```
步骤1: IO传感器感应包裹
→ 物理传感器检测到包裹通过
→ 触发包裹创建事件

步骤2: WheelDiverterSorter创建包裹记录
→ ParcelId: "PKG001" (系统生成)
→ Timestamp: 记录包裹到达时间
→ Status: "待分配格口"
```

### 阶段2：格口决策（RuleEngine.Core）

```
步骤3: WheelDiverterSorter 通知 RuleEngine 包裹已检测（推送模型）
→ 通过TCP/SignalR/MQTT调用 NotifyParcelDetectedAsync(parcelId)
→ Message: { ParcelId: "PKG001", DetectedAt: "2025-11-19T12:00:00Z" }
→ **注意**：这是一个通知调用，不等待返回格口号
→ WheelDiverterSorter 开始等待 RuleEngine 推送结果（启动 TTL 计时器）

步骤4: RuleEngine接收通知，查询DWS第三方API
→ 根据包裹ID查询DWS系统
→ 获取包裹详细信息：
   - Barcode: "1234567890"
   - Weight: 1500g
   - Length: 30cm, Width: 20cm, Height: 15cm
   - Volume: 9000cm³

步骤5: RuleEngine调用其他第三方API（可选）
→ 邮政API、ERP、WMS等
→ 获取补充业务信息

步骤6: 规则引擎处理
→ 评估规则（6种匹配方法）
→ 选择优先级最高的匹配规则
→ 决定目标格口

步骤7: RuleEngine **主动推送**格口号（推送模型）
→ 通过TCP/SignalR/MQTT **推送**结果到 WheelDiverterSorter
→ Message: { ParcelId: "PKG001", ChuteNumber: "CHUTE_A" }
→ WheelDiverterSorter 接收推送 → 完成格口分配 → 停止 TTL 计时器

**超时处理（TTL机制）：**
→ 如果 RuleEngine 在 TTL 时间内（默认10秒）未推送结果
→ WheelDiverterSorter 自动触发超时处理：
   - 异常类型：`UpstreamTimeout`
   - 路由目标：异常格口（配置中的 ExceptionChuteId）
   - 异常原因：等待上游结果超时
```

### 阶段3：摆轮执行（WheelDiverterSorter）

```
步骤8: WheelDiverterSorter接收格口号
→ ParcelId: "PKG001"
→ TargetChuteId: "CHUTE_A"

步骤9: 生成摆轮路径
→ 查询配置数据库（LiteDB）
→ 格口A的映射：
  [
    { DiverterId: "D1", TargetAngle: 30, TTL: 5000ms },
    { DiverterId: "D2", TargetAngle: 45, TTL: 5000ms }
  ]

步骤10: 执行路径段（实际分拣）
→ 段1: 摆轮D1旋转到30°，等待包裹通过
→ 段2: 摆轮D2旋转到45°，等待包裹通过

步骤11: 返回执行结果
→ Success: true
→ ActualChuteId: "CHUTE_A"
→ Message: "分拣成功"
```

---

## 数据流向

### 双向数据交互

| 数据项 | 来源 | 去向 | 通信方式 | 说明 |
|-------|-----|-----|---------|-----|
| ParcelId | WheelDiverterSorter (IO传感器) | RuleEngine | TCP/SignalR/MQTT | 包裹唯一标识符 |
| ChuteNumber | RuleEngine (决策输出) | WheelDiverterSorter | TCP/SignalR/MQTT | 目标格口号 |
| Barcode/Weight/Size | DWS第三方系统 | RuleEngine | HTTP API | 包裹物理属性数据 |
| ExecutionResult | WheelDiverterSorter | （本地记录） | - | 分拣执行结果 |

**关键要点：**
1. **WheelDiverterSorter负责包裹创建**：通过IO传感器感应包裹并创建记录
2. **RuleEngine负责与DWS通信**：调用DWS第三方API获取包裹信息和格口号
3. **WheelDiverterSorter负责实际分拣**：根据格口号执行摆轮动作
4. **分开部署**：两个系统独立运行，通过网络通信协议交互

### 集成方式对比

**当前状态：**
- ⚠️ **两个系统独立部署运行**
- ⚠️ **需要实现通信层对接**
- ⚠️ **支持多种通信协议可选**

**生产环境推荐集成方式（已在"部署模型与通信方式"章节详细说明）：**

#### ✅ 推荐方式1：TCP Socket
- 低延迟、高吞吐量
- 适合实时控制场景
- 长连接，减少握手开销

#### ✅ 推荐方式2：SignalR
- 实时双向通信
- 自动重连机制
- RuleEngine已内置支持

#### ✅ 推荐方式3：MQTT
- 解耦性强
- 支持消息持久化
- 适合多节点部署

#### ❌ 禁止方式：HTTP REST API
- 仅用于开发测试
- 生产环境性能不足
- 同步阻塞调用

**详细的通信协议配置和对比，请参见上文"部署模型与通信方式"章节。**

---

## 集成实施路线图（待开发）

### 第1阶段：IO传感器集成（WheelDiverterSorter）

**目标**：实现物理包裹感应和包裹创建

- [ ] 实现IO传感器监听模块（Ingress层）
- [ ] 支持多种传感器类型（光电、激光等）
- [ ] 包裹创建事件触发机制
- [ ] 包裹ID生成策略

**估计工期**：2-3周

### 第2阶段：通信层开发（双方）

**目标**：实现两个系统之间的通信对接

**WheelDiverterSorter端：**
- [ ] 实现TCP/SignalR/MQTT客户端
- [ ] 支持多种通信协议配置切换
- [ ] 请求格口号接口
- [ ] 连接管理和错误处理

**RuleEngine端：**
- [ ] 接收包裹ID请求
- [ ] 与DWS第三方API集成
- [ ] 返回格口号响应
- [ ] （RuleEngine已支持多种通信协议）

**估计工期**：3-4周

### 第3阶段：联调测试

**目标**：端到端测试完整流程

- [ ] 模拟环境联调
- [ ] 性能测试（吞吐量、延迟）
- [ ] 异常场景测试
- [ ] 压力测试

**估计工期**：2-3周

### 第4阶段：生产部署

**目标**：部署到生产环境

- [ ] 选择最佳通信协议
- [ ] 配置生产环境参数
- [ ] 监控和告警设置
- [ ] 运维文档编写

**估计工期**：1-2周

---

## 原有集成说明（已过时，仅供参考）

以下是原文档中的集成方式说明，**已过时**，请参考上文"部署模型与通信方式"章节的最新说明：

<details>
<summary>点击展开原有集成说明（已过时）</summary>

#### 方式1：REST API集成（仅测试用）
```
规则引擎 → HTTP POST → 摆轮系统

POST http://wheeldiverter:5000/api/debug/sort
{
  "parcelId": "PKG001",
  "targetChuteId": "CHUTE_A"
}
```

**优点：**
- ✅ 简单易实现
- ✅ 松耦合
- ✅ 支持HTTP标准

**缺点：**
- ⚠️ 同步调用，可能阻塞
- ⚠️ 需要处理HTTP超时和重试
- ⚠️ 生产环境禁止使用

#### 方式2：消息队列集成
```
规则引擎 → RabbitMQ/Kafka → 摆轮系统

Topic: "sorting.chute.assignment"
Message: { parcelId, chuteNumber, timestamp }
```

**优点：**
- ✅ 异步解耦
- ✅ 高可靠性，支持重试
- ✅ 可扩展性强

**缺点：**
- ⚠️ 需要额外的消息队列服务
- ⚠️ 复杂度增加

#### 方式3：SignalR实时通信
```
规则引擎 → SignalR Hub → 摆轮系统

Hub Method: "AssignParcelToChute"
Parameters: { parcelId, chuteNumber }
```

**优点：**
- ✅ 实时双向通信
- ✅ 规则引擎已支持SignalR
- ✅ 自动重连机制

**缺点：**
- ⚠️ 摆轮系统需要实现SignalR客户端
- ⚠️ 需要维持长连接

</details>

---

## 系统对比

| 特性 | 规则引擎 | 摆轮系统 |
|-----|---------|---------|
| **部署方式** | 独立部署 | 独立部署 |
| **定位** | 上游决策层 | 下游执行层 |
| **核心功能** | 决定去哪个格口 | 如何到达格口 + 包裹创建 |
| **职责** | 与DWS第三方API通信 | IO传感器感应 + 实际分拣 |
| **完成度** | 87% | 70% |
| **架构模式** | 事件驱动 + CQRS | 分层架构 |
| **数据库** | LiteDB + MySQL + SQLite | LiteDB |
| **通信协议** | SignalR, TCP, MQTT, HTTP | 需要实现（推荐TCP/SignalR/MQTT） |
| **外部集成** | 6种第三方API (DWS等) | 无（通过RuleEngine间接集成） |
| **规则引擎** | 6种匹配方法 | 无 |
| **路径规划** | 无 | 摆轮路径生成 |
| **设备控制** | 无 | 摆轮角度控制 + IO传感器 |
| **测试工具** | DataSimulator, InterfaceSimulator | 调试API |
| **单元测试** | 310+ | 无 |
| **热更新** | 规则配置热更新 | 格口配置热更新 |

---

## 配合使用场景

### 场景1：标准包裹分拣流程

```
1. DWS扫描包裹 → 规则引擎
   
2. 规则引擎决定格口A → 摆轮系统
   
3. 摆轮系统生成路径 [D1:30°, D2:45°] → 执行
   
4. 包裹成功到达格口A
```

### 场景2：异常包裹处理

```
1. DWS扫描异常包裹 → 规则引擎
   
2. 规则引擎无匹配规则 → 返回异常格口 "CHUTE_EXCEPTION"
   
3. 摆轮系统生成异常口路径 → 执行
   
4. 包裹到达异常格口等待人工处理
```

### 场景3：高并发批量处理

```
1. WheelDiverterSorter: IO传感器感应1000个包裹
   
2. WheelDiverterSorter: 通过TCP/SignalR/MQTT请求格口号
   
3. RuleEngine: FIFO队列接收请求，与DWS API通信，并发评估规则
   
4. WheelDiverterSorter: 接收格口号批次，按序执行摆轮路径
```

---

## 部署架构建议

### 单机部署（测试环境）

```
┌─────────────────────────────────────────┐
│         服务器                           │
│                                         │
│  ┌───────────────────────────────┐    │
│  │  规则引擎服务 :5000            │    │
│  │  (RuleEngine.Core)            │    │
│  └───────────┬───────────────────┘    │
│              │ TCP/SignalR/MQTT        │
│  ┌───────────▼───────────────────┐    │
│  │  摆轮系统服务 :5001            │    │
│  │  (WheelDiverterSorter)        │    │
│  └───────────────────────────────┘    │
│                                         │
│  ┌───────────────────────────────┐    │
│  │  MySQL数据库 :3306             │    │
│  │  (RuleEngine日志)              │    │
│  └───────────────────────────────┘    │
└─────────────────────────────────────────┘
```

**适用场景：**
- 小规模部署（<100包裹/分钟）
- 开发和测试环境
- ⚠️ 注意：两个服务独立运行，但在同一服务器

### 分布式部署（生产环境）

```
┌───────────────────┐    ┌───────────────────┐
│  规则引擎集群      │    │  摆轮系统集群      │
│  (独立部署)       │    │  (独立部署)        │
│                   │    │                   │
│  ┌─────┐ ┌─────┐ │    │  ┌─────┐ ┌─────┐ │
│  │ RE1 │ │ RE2 │ │    │  │ WD1 │ │ WD2 │ │
│  └─────┘ └─────┘ │    │  └─────┘ └─────┘ │
└────────┬──────────┘    └────────┬──────────┘
         │                        │
         └────────┬───────────────┘
                  │ TCP/SignalR/MQTT
         ┌────────▼─────────┐
         │  MQTT Broker     │
         │  (可选)          │
         └──────────────────┘
                  │
         ┌────────▼─────────┐
         │  MySQL主从集群   │
         │  (RuleEngine)    │
         └──────────────────┘
```

**适用场景：**
- 大规模生产环境（500-1000包裹/秒）
- 高可用性要求
- ⚠️ 注意：两个集群完全独立部署，通过网络通信

**关键部署要点：**
1. **独立部署**：规则引擎和摆轮系统必须分开部署
2. **通信协议**：生产环境使用TCP/SignalR/MQTT，禁止HTTP
3. **负载均衡**：每个系统可独立扩展
4. **高可用**：每个系统独立容错和重启

---

## 原有集成路线图（已过时，请参考上文"集成实施路线图"）

以下内容已过时，新的集成路线图请参考上文：

<details>
<summary>点击展开原有路线图（已过时）</summary>

### 第1阶段：适配器开发（1-2周）

- [ ] 在规则引擎中添加摆轮系统客户端
- [ ] 实现HTTP API调用
- [ ] 添加错误处理和重试机制
- [ ] 单元测试覆盖

### 第2阶段：消息队列集成（2-4周）

- [ ] 引入RabbitMQ或Kafka
- [ ] 规则引擎发布格口分配消息
- [ ] 摆轮系统订阅并处理消息
- [ ] 实现消息确认和重试

### 第3阶段：性能优化（持续）

- [ ] 批量处理优化
- [ ] 并发控制和队列管理
- [ ] 监控和告警集成
- [ ] 压力测试（1000包裹/秒）

### 第4阶段：统一管理平台（3-6个月）

- [ ] 开发Web管理界面
- [ ] 统一配置管理
- [ ] 统一日志查询
- [ ] 实时监控仪表板

</details>

---

## 技术栈兼容性

| 技术 | 规则引擎 | 摆轮系统 | 兼容性 | 备注 |
|-----|---------|---------|--------|-----|
| .NET版本 | .NET 8.0 | .NET 8.0 | ✅ 完全兼容 | 版本一致 |
| Web框架 | ASP.NET Core | ASP.NET Core Minimal API | ✅ 完全兼容 | 框架兼容 |
| 依赖注入 | ✅ | ✅ | ✅ 完全兼容 | 都使用DI |
| SignalR | ✅ | ❌ | ⚠️ 需要添加 | 生产环境推荐 |
| TCP通信 | ✅ (TouchSocket) | ❌ | ⚠️ 需要添加 | 生产环境推荐 |
| MQTT | ✅ (MQTTnet) | ❌ | ⚠️ 需要添加 | 生产环境推荐 |
| LiteDB | ✅ | ✅ | ✅ 完全兼容 | 都使用 |
| MySQL | ✅ | ❌ | ⚠️ 可选 | RuleEngine用于日志 |
| 配置热更新 | ✅ | ✅ | ✅ 完全兼容 | 都支持 |

---

## 常见问题

### Q1: 两个系统是如何部署的？

**答：** 
两个系统是**完全独立部署**的：

- **规则引擎（RuleEngine.Core）**：独立服务器/容器，负责与DWS第三方API通信并决策格口
- **摆轮系统（WheelDiverterSorter）**：独立服务器/容器，负责IO传感器感应、创建包裹和实际分拣
- 两者通过TCP/SignalR/MQTT等网络协议通信
- 可以独立启动、停止、升级和维护

### Q2: WheelDiverterSorter如何创建包裹？

**答：**
- 通过**IO传感器**（光电传感器、激光传感器等）感应物理包裹通过
- 传感器触发事件后，WheelDiverterSorter在系统中创建包裹记录
- 创建包裹时生成唯一的ParcelId
- 然后向RuleEngine请求该包裹应该去哪个格口

### Q3: RuleEngine如何获取包裹信息？

**答：**
- RuleEngine接收WheelDiverterSorter发送的包裹ID
- 根据包裹ID调用**DWS第三方API**查询包裹详细信息（条码、重量、尺寸等）
- 可选地调用其他第三方API（邮政、ERP、WMS等）
- 使用规则引擎评估并决定目标格口号
- 将格口号返回给WheelDiverterSorter

### Q4: 为什么生产环境禁止使用HTTP？

**答：**
- **性能问题**：HTTP是同步阻塞调用，每次请求都需要建立连接，开销大
- **连接开销**：短连接频繁建立/销毁TCP连接，浪费资源
- **无重连机制**：网络抖动时容易失败，需要复杂的重试逻辑
- **吞吐量低**：无法支持高并发场景（500-1000包裹/秒）
- **推荐方案**：使用TCP/SignalR/MQTT长连接，延迟低、吞吐量高

### Q5: 如何保证数据一致性？

**答：**
- 使用TCP/SignalR/MQTT确保可靠传递
- 实现幂等性保护，避免重复处理
- 添加事务日志，支持数据追溯
- 定期对账和数据同步
- 通信层添加确认和重试机制

### Q6: 性能瓶颈在哪里？

**答：**
- 规则引擎：规则评估和DWS API调用（已优化到50ms P99延迟）
- 摆轮系统：路径生成和执行（取决于物理设备速度）
- 网络通信：使用TCP/SignalR/MQTT可达到<10ms延迟

### Q7: 支持多少并发？

**答：**
- 规则引擎：支持1000包裹/秒（单实例）
- 摆轮系统：取决于摆轮设备数量和响应速度
- 集成后：使用TCP/SignalR/MQTT通信，理论上可支持10000+包裹/秒

### Q8: 如何处理异常情况？

**答：**
- WheelDiverterSorter：IO传感器故障或网络断开时记录异常
- 规则引擎：无匹配规则或DWS API调用失败时返回异常格口
- 摆轮系统：路径执行失败时返回异常格口
- 集成层：添加错误重试和降级策略
- 监控告警：实时监控异常率并告警

---

## 联系方式

**规则引擎项目：**
- GitHub: https://github.com/Hisoka6602/ZakYip.Sorting.RuleEngine.Core
- Issues: https://github.com/Hisoka6602/ZakYip.Sorting.RuleEngine.Core/issues

**摆轮系统项目：**
- GitHub: https://github.com/Hisoka6602/ZakYip.WheelDiverterSorter
- Issues: https://github.com/Hisoka6602/ZakYip.WheelDiverterSorter/issues

---

## 总结

✅ **系统部署模型明确：**
   - **两个系统分开部署**，各自独立运行
   - **WheelDiverterSorter（下游）**: 通过IO传感器感应包裹并创建记录，负责实际分拣执行
   - **RuleEngine.Core（上游）**: 与DWS第三方API通信获取包裹信息，负责格口决策

✅ **通信方式清晰：**
   - 支持**多种通信协议**（TCP/SignalR/MQTT/HTTP等，多选一）
   - **生产环境推荐**：TCP、SignalR或MQTT（高性能、长连接）
   - **生产环境禁止**：HTTP（仅用于模拟测试，性能不足）

✅ **职责划分明确：**
   - **WheelDiverterSorter**：包裹创建（IO传感器） + 实际分拣（摆轮控制）
   - **RuleEngine.Core**：与DWS第三方API通信 + 格口号决策
   - 两者通过网络协议进行数据交互

✅ **架构兼容性强：**
   - 都基于.NET 8.0和ASP.NET Core
   - 支持独立扩展和负载均衡
   - 具备良好的可维护性和可扩展性

📝 **本文档提供了：**
   - 详细的部署架构说明
   - 完整的通信协议对比
   - 清晰的集成实施路线图
   - 常见问题解答

---

**文档版本：** 2.0  
**创建日期：** 2025-11-12  
**最后更新：** 2025-11-12
