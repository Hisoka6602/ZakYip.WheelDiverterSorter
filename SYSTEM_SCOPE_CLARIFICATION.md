# 系统范围说明文档

## 文档目的

本文档明确说明 **ZakYip.WheelDiverterSorter（摆轮分拣系统）** 的功能边界和设计决策，澄清哪些功能**有意不实现**，避免误解为功能缺失。

---

## 系统定位

**ZakYip.WheelDiverterSorter** 是一个**纯执行层系统**，专注于物理分拣动作的执行。

```
┌────────────────────────────────────────────────────────┐
│  ZakYip.Sorting.RuleEngine.Core (上游决策层)            │
│  - 与DWS第三方API通信获取包裹信息                       │
│  - 规则引擎决策格口号                                   │
│  - 存储包裹历史数据                                     │
│  - 提供数据报表                                         │
└───────────────────┬────────────────────────────────────┘
                    │ TCP/SignalR/MQTT通信
                    │ (传递格口号)
┌───────────────────▼────────────────────────────────────┐
│  ZakYip.WheelDiverterSorter (下游执行层)               │
│  - IO传感器感应包裹                                     │
│  - 创建包裹记录                                         │
│  - 请求格口号                                           │
│  - 生成摆轮路径                                         │
│  - 执行物理分拣                                         │
└────────────────────────────────────────────────────────┘
```

---

## 有意不实现的功能

以下功能根据系统架构设计，**有意不在本系统中实现**：

### 1. ❌ 扫码触发集成
- **原因**：本系统使用 **IO传感器** 感应物理包裹到达，不依赖条码扫描
- **实现方式**：
  - 传感器类型：光电传感器、激光传感器
  - 触发机制：物理遮挡触发
  - 包裹ID生成：基于触发时间戳的唯一ID
- **上游集成**：上游RuleEngine通过DWS API获取条码信息（如需要）

### 2. ❌ 供包台关联
- **原因**：本系统仅需与上游RuleEngine通信获取格口号，不需要直接与供包台交互
- **实现方式**：
  - 通过TCP/SignalR/MQTT向RuleEngine请求格口号
  - 上游RuleEngine负责与供包台等外部系统的集成
- **好处**：解耦架构，降低复杂度

### 3. ❌ 包裹历史存储
- **原因**：上游RuleEngine已存储包裹数据和历史记录
- **实现方式**：
  - 本系统仅执行分拣，不持久化包裹信息
  - 需要历史查询时，访问RuleEngine的数据库
- **好处**：避免数据重复存储，降低维护成本

### 4. ❌ 数据报表功能
- **原因**：报表和统计功能由上游RuleEngine提供
- **实现方式**：
  - RuleEngine聚合所有包裹数据生成报表
  - 分拣效率、成功率等指标由RuleEngine计算
- **好处**：统一数据源，报表更准确

---

## 系统核心职责

本系统专注于以下核心功能：

### ✅ 1. 包裹检测
- **功能**：通过IO传感器感应物理包裹到达
- **实现**：
  ```
  IO传感器触发 → 创建包裹记录 → 生成唯一包裹ID
  ```
- **传感器支持**：
  - 光电传感器 (Photoelectric)
  - 激光传感器 (Laser)
  - 支持多厂商（当前：雷赛）

### ✅ 2. 格口决策获取
- **功能**：向上游RuleEngine请求格口号
- **实现**：
  ```
  发送包裹ID → RuleEngine决策 → 接收格口号
  ```
- **通信协议**：
  - TCP Socket（推荐）
  - SignalR
  - MQTT
  - HTTP（仅测试用）

### ✅ 3. 摆轮路径生成
- **功能**：根据格口号生成有序的摆轮动作序列
- **实现**：
  ```
  格口ID → 查询配置 → 生成路径段列表
  ```
- **配置管理**：
  - LiteDB存储格口到摆轮的映射
  - 支持热更新，无需重启

### ✅ 4. 物理分拣执行
- **功能**：控制摆轮角度，完成包裹分拣
- **实现**：
  ```
  路径段列表 → 按序执行 → 监控TTL → 返回结果
  ```
- **执行器支持**：
  - 模拟执行器（测试用）
  - 硬件执行器（雷赛控制器）

### ✅ 5. 异常处理
- **功能**：连接失败时自动路由到异常格口
- **实现**：
  ```
  RuleEngine连接失败 → 使用异常格口ID → 生成路径 → 执行
  ```
- **配置**：
  - 异常格口ID：`CHUTE_EXCEPTION`（可配置）
  - 超时时间：10秒（可配置）

---

## 异常处理策略

### 场景1：RuleEngine连接失败
```
包裹检测 → 尝试连接RuleEngine → 连接失败
         ↓
    记录错误日志
         ↓
    使用异常格口ID
         ↓
    生成异常格口路径
         ↓
    执行物理分拣
```

**代码位置**：`ParcelSortingOrchestrator.cs` 第172-182行

### 场景2：格口分配超时
```
包裹检测 → 发送通知到RuleEngine → 等待格口分配
         ↓
    超时（默认10秒）
         ↓
    记录超时日志
         ↓
    使用异常格口ID
         ↓
    执行物理分拣
```

**代码位置**：`ParcelSortingOrchestrator.cs` 第194-217行

### 场景3：路径生成失败
```
接收格口号 → 生成摆轮路径 → 路径生成失败
         ↓
    记录警告日志
         ↓
    尝试生成异常格口路径
         ↓
    执行物理分拣
```

**代码位置**：`ParcelSortingOrchestrator.cs` 第247-266行

---

## 配置说明

### 异常格口配置
```json
{
  "SystemConfiguration": {
    "ExceptionChuteId": "CHUTE_EXCEPTION",
    "ChuteAssignmentTimeoutMs": 10000
  }
}
```

### RuleEngine通信配置
```json
{
  "RuleEngine": {
    "CommunicationMode": "TCP",
    "Server": "192.168.1.100:8888",
    "EnableAutoReconnect": true,
    "RequestTimeoutMs": 5000,
    "RetryCount": 3
  }
}
```

### 传感器配置
```json
{
  "Sensor": {
    "UseHardwareSensor": true,
    "VendorType": "Leadshine",
    "Leadshine": {
      "CardNo": 0,
      "Sensors": [
        {
          "SensorId": "SENSOR_ENTRANCE",
          "Type": "Photoelectric",
          "InputBit": 0,
          "IsEnabled": true
        }
      ]
    }
  }
}
```

---

## 数据流向

### 正常流程
```
1. IO传感器 → 检测包裹 → 创建包裹记录（包裹ID）
2. 本系统 → 发送包裹ID → RuleEngine
3. RuleEngine → 查询DWS API → 获取包裹信息（条码、重量等）
4. RuleEngine → 规则引擎决策 → 返回格口号
5. 本系统 → 生成摆轮路径 → 执行物理分拣
6. RuleEngine → 存储包裹历史 → 生成报表
```

### 异常流程
```
1. IO传感器 → 检测包裹 → 创建包裹记录（包裹ID）
2. 本系统 → 尝试连接RuleEngine → 失败
3. 本系统 → 记录错误 → 使用异常格口ID
4. 本系统 → 生成异常格口路径 → 执行物理分拣
5. 包裹到达异常格口 → 等待人工处理
```

---

## 常见问题

### Q1: 为什么不支持扫码触发？
**A:** 本系统使用IO传感器物理检测包裹，更可靠且不依赖条码可读性。如需条码信息，由上游RuleEngine通过DWS API获取。

### Q2: 为什么不存储包裹历史？
**A:** 上游RuleEngine已完整存储所有包裹数据。本系统重复存储会增加复杂度和维护成本，且容易造成数据不一致。

### Q3: 如何查询分拣历史？
**A:** 通过上游RuleEngine的API或数据库查询。RuleEngine提供完整的包裹追踪和报表功能。

### Q4: RuleEngine宕机时系统如何工作？
**A:** 系统会自动检测连接失败，将所有包裹路由到异常格口。恢复连接后自动恢复正常分拣。

### Q5: 如何知道哪些包裹走了异常格口？
**A:** 查看本系统的日志记录，或查询RuleEngine的历史数据（如连接正常且通知成功）。

---

## 总结

| 功能类别 | 责任方 | 说明 |
|---------|--------|------|
| 包裹检测 | WheelDiverterSorter | IO传感器物理检测 |
| 包裹信息获取 | RuleEngine | DWS API获取条码、重量等 |
| 格口决策 | RuleEngine | 规则引擎评估 |
| 摆轮路径生成 | WheelDiverterSorter | 格口到摆轮映射 |
| 物理分拣 | WheelDiverterSorter | 控制摆轮执行 |
| 包裹历史 | RuleEngine | 持久化存储 |
| 数据报表 | RuleEngine | 统计分析 |

**设计原则**：
- ✅ 单一职责：WheelDiverterSorter专注执行层
- ✅ 松耦合：通过网络协议与RuleEngine通信
- ✅ 故障容错：RuleEngine不可用时自动降级
- ✅ 简单高效：不存储冗余数据，不实现无关功能

---

**文档版本**: 1.0  
**创建日期**: 2025-11-13  
**最后更新**: 2025-11-13
