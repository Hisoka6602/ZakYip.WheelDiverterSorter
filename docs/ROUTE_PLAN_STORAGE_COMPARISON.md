# 路由计划存储方案对比：内存缓存 vs LiteDB

> **文档目的**：分析包裹路由计划存储从 LiteDB 切换到内存缓存的优势与劣势

---

## 一、核心问题回顾

### 1.1 LiteDB 存在的问题

**原始问题**：
```
时间戳 ParcelId 在 LiteDB 中出现重复键/空键异常
```

**根本原因分析**：

1. **ParcelId 生成机制**：
   - ParcelId 使用时间戳生成（如 `DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()`）
   - 高并发场景下，多个包裹可能在同一毫秒内创建，导致 ParcelId 重复

2. **LiteDB 唯一索引约束**：
   ```csharp
   _collection.EnsureIndex(x => x.ParcelId, unique: true);
   ```
   - LiteDB 强制执行唯一索引，重复 ParcelId 直接抛异常
   - 异常未被妥善处理，可能影响分拣流程

3. **空键异常**：
   - 当 `ParcelId <= 0` 时（如初始化失败），LiteDB 可能拒绝插入
   - 验证逻辑在 `SaveAsync` 中，但异常处理不完善

### 1.2 业务需求

**路由计划的生命周期特点**：
- **短暂性**：包裹从检测到落格通常只需 10-30 秒
- **一次性**：包裹完成分拣后，路由计划即可丢弃
- **改口窗口**：仅在包裹到达摆轮之前的几秒内有效
- **无历史查询需求**：完成分拣后不需要查询历史路由计划

**核心需求**：
- ✅ 支持高并发读写（多个包裹同时分拣）
- ✅ 快速查询（改口决策需要毫秒级响应）
- ✅ 异常隔离（存储失败不能影响分拣）
- ❌ 不需要持久化（重启后历史路由计划无意义）
- ❌ 不需要长期保留（自动过期即可）

---

## 二、方案对比

### 2.1 性能对比

| 指标 | 内存缓存 (IMemoryCache) | LiteDB |
|------|------------------------|---------|
| **写入性能** | **~0.001ms** (内存操作) | ~1-10ms (磁盘 I/O) |
| **读取性能** | **~0.0001ms** (字典查找) | ~0.5-5ms (索引查询) |
| **并发性能** | **线程安全字典，无锁争用** | 文件锁，高并发时性能下降 |
| **内存占用** | ~200-500 bytes/条目 | ~1KB/条目（文件缓存） |
| **磁盘占用** | 0 | 持续增长（需手动清理） |

**性能优势总结**：
- ⚡ **写入速度提升 1000-10000 倍**（内存 vs 磁盘）
- ⚡ **读取速度提升 5000-50000 倍**（字典 vs B+树索引）
- ⚡ **零磁盘 I/O**，不受磁盘性能瓶颈影响

### 2.2 可靠性对比

| 指标 | 内存缓存 | LiteDB |
|------|---------|---------|
| **数据持久化** | ❌ 进程重启丢失 | ✅ 持久化到磁盘 |
| **崩溃恢复** | ❌ 无法恢复 | ✅ 可恢复（但本场景不需要） |
| **唯一键冲突** | ✅ **自动覆盖，无异常** | ❌ **抛异常，需处理** |
| **空键处理** | ✅ **验证后静默失败** | ❌ **插入失败，抛异常** |
| **异常隔离** | ✅ **ISafeExecutionService 包裹** | ⚠️ 需手动包裹 |
| **自动清理** | ✅ **3分钟滑动过期** | ❌ 需手动删除或定期清理 |

**可靠性优势总结**：
- 🛡️ **内存缓存更符合"临时数据"的语义**
- 🛡️ **自动过期机制防止内存泄漏**
- 🛡️ **键冲突自动处理，不抛异常**
- 🛡️ **所有操作已通过 SafeExecutionService 隔离异常**

### 2.3 运维对比

| 指标 | 内存缓存 | LiteDB |
|------|---------|---------|
| **部署复杂度** | ✅ 无需额外配置 | ⚠️ 需创建 Data 目录 |
| **监控复杂度** | ✅ .NET MemoryCache 指标 | ⚠️ 需监控数据库文件大小 |
| **磁盘空间管理** | ✅ 无需管理 | ❌ **需定期清理旧数据** |
| **备份需求** | ✅ 无需备份 | ⚠️ 如需历史分析需备份 |
| **跨平台兼容性** | ✅ 完全兼容 | ✅ 兼容（但 Windows/Linux 路径问题） |

**运维优势总结**：
- 🔧 **零运维成本**（无需磁盘清理、备份、监控）
- 🔧 **部署更简单**（删除了数据库路径配置）

### 2.4 代码复杂度对比

**DI 注册对比**：

```csharp
// ❌ LiteDB 版本（11 行）
services.AddSingleton<IRoutePlanRepository>(sp =>
{
    var dbPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Data", "route_plans.db");
    var directory = Path.GetDirectoryName(dbPath);
    if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
    {
        Directory.CreateDirectory(directory);
    }
    return new LiteDbRoutePlanRepository(dbPath);
});

// ✅ 内存缓存版本（1 行）
services.AddSingleton<IRoutePlanRepository, InMemoryRoutePlanRepository>();
```

**实现代码对比**：

| 指标 | 内存缓存 | LiteDB |
|------|---------|---------|
| **代码行数** | ~140 行 | ~120 行 |
| **依赖项** | IMemoryCache, ISafeExecutionService | LiteDB NuGet 包 |
| **异常处理** | ✅ 所有操作已包裹 | ⚠️ 部分操作需手动包裹 |
| **Dispose 需求** | ❌ 无需释放 | ✅ 需实现 IDisposable |

---

## 三、优势总结

### 3.1 核心优势（为什么内存缓存更适合路由计划存储）

| 优势类型 | 具体优势 | 业务价值 |
|---------|---------|---------|
| **🚀 性能** | 读写性能提升 1000-10000 倍 | 支持更高吞吐量，降低延迟 |
| **🛡️ 稳定性** | 键冲突自动处理，不抛异常 | **彻底解决 ParcelId 重复键问题** |
| **🧹 自动清理** | 3分钟滑动过期，自动释放内存 | 防止内存泄漏，无需手动清理 |
| **🔧 简化运维** | 零磁盘占用，零配置 | 降低运维成本，简化部署 |
| **💡 语义正确** | 临时数据用临时存储 | 代码意图更清晰 |

### 3.2 劣势与风险（需要注意的点）

| 劣势类型 | 具体劣势 | 缓解措施 |
|---------|---------|---------|
| **❌ 进程重启丢失数据** | 重启时未完成的路由计划丢失 | ✅ **不影响业务**：重启时系统状态清空，包裹重新检测 |
| **❌ 无法追溯历史** | 无法查询已完成包裹的路由变更历史 | ✅ **不需要**：改口记录已通过日志和事件记录 |
| **❌ 内存上限** | 高并发时可能占用大量内存 | ✅ **滑动过期 + 高优先级**：3分钟后自动清理 |

---

## 四、结论与建议

### 4.1 结论

**内存缓存明显优于 LiteDB**，原因如下：

1. ✅ **彻底解决核心问题**：
   - LiteDB 的唯一索引约束导致 ParcelId 重复时抛异常
   - 内存缓存自动覆盖，无异常，符合"最后一次更新有效"的语义

2. ✅ **性能提升巨大**：
   - 读写性能提升 1000-10000 倍
   - 零磁盘 I/O，适合高并发场景

3. ✅ **运维成本降低**：
   - 无需管理磁盘空间
   - 自动过期机制，无需手动清理

4. ✅ **语义更正确**：
   - 路由计划是**临时数据**（生命周期 10-30 秒）
   - 持久化到磁盘是**过度设计**

### 4.2 建议

**强烈推荐使用内存缓存**，理由：

1. **业务匹配度**：
   - 路由计划的短暂性（10-30 秒）与内存缓存的滑动过期（3 分钟）完美匹配
   - 无历史查询需求，持久化无意义

2. **风险可控**：
   - 进程重启丢失数据不影响业务（系统会重新检测包裹）
   - 内存占用可控（3分钟滑动过期）

3. **可维护性**：
   - 代码更简洁（DI 注册从 11 行降至 1 行）
   - 依赖更少（删除 LiteDB NuGet 包）

4. **异常隔离**：
   - 所有操作已通过 `ISafeExecutionService` 包裹
   - 存储失败不会影响分拣流程（符合新需求：**任何异常都需要隔离，不能影响系统分拣包裹**）

---

## 五、附录：关键设计决策

### 5.1 为什么选择 3 分钟滑动过期？

**计算依据**：
- 包裹分拣周期：10-30 秒（正常情况）
- 异常超时时间：10 秒（配置的 `ChuteAssignmentTimeout`）
- 改口窗口：包裹检测后到第一个摆轮之间（通常 5-10 秒）
- **安全系数**：3 分钟 = 180 秒 = 6 倍于正常周期

**优势**：
- ✅ 足够长，覆盖所有正常和异常情况
- ✅ 足够短，防止内存长期驻留

### 5.2 为什么用 ISafeExecutionService 包裹所有操作？

**原因**：
- 符合新需求：**任何异常都需要隔离，不能影响系统分拣包裹**
- 内存缓存操作虽然简单，但仍可能抛异常：
  - `ArgumentNullException`（参数验证）
  - `OutOfMemoryException`（极端情况）
  - `InvalidOperationException`（并发冲突）

**效果**：
- 所有异常被捕获并记录日志
- 分拣流程不受影响，继续执行

### 5.3 为什么保留 IRoutePlanRepository 接口？

**原因**：
- 符合依赖倒置原则（Dependency Inversion Principle）
- 便于未来扩展（如需要其他存储方案）
- 便于单元测试（可使用 Mock 实现）

**好处**：
- 调用方（`SortingOrchestrator`, `ChangeParcelChuteService`）无需修改
- 切换存储方案只需修改 DI 注册

---

**文档版本**：1.0  
**创建时间**：2025-12-24  
**维护团队**：ZakYip Development Team
