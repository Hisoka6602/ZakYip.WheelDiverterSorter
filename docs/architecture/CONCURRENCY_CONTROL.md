# 并发控制机制文档

## 概述

本文档描述了直线摆轮分拣系统的并发控制机制。该机制解决了多个包裹同时请求同一摆轮时可能产生的冲突问题，确保系统在高并发场景下的稳定性和分拣效率。

## 问题背景

### 原有系统存在的问题

1. **并发冲突**：多个包裹同时请求同一摆轮时，可能产生竞态条件
2. **频繁切换**：摆轮角度频繁切换，降低分拣效率
3. **分拣错误**：高并发场景下可能导致分拣错误
4. **系统过载**：缺乏限流保护，系统容易过载

### 风险影响

- 摆轮角度切换频繁，降低分拣效率
- 分拣错误率升高
- 高并发场景下系统不可用

## 解决方案

### 1. 摆轮资源锁机制

#### 核心组件

- **`IDiverterResourceLock`**: 摆轮资源锁接口
- **`DiverterResourceLock`**: 基于 `ReaderWriterLockSlim` 的锁实现
- **`IDiverterResourceLockManager`**: 锁管理器接口
- **`DiverterResourceLockManager`**: 管理所有摆轮的锁实例

#### 工作原理

```
包裹A请求摆轮D1 → 获取D1写锁 → 控制D1 → 释放D1写锁
包裹B请求摆轮D1 → 等待D1写锁 → 获取锁 → 控制D1 → 释放锁
```

#### 特性

- **读写锁分离**：支持多个读操作，写操作互斥
- **超时机制**：获取锁超时后自动失败，避免死锁
- **自动释放**：使用 `IDisposable` 模式确保锁自动释放

### 2. 包裹队列管理

#### 核心组件

- **`IParcelQueue`**: 包裹队列接口
- **`PriorityParcelQueue`**: 优先级队列实现
- **`ParcelQueueItem`**: 包裹队列项

#### 工作原理

```
包裹入队 → 优先级排序 → 批量处理相同目标 → 执行分拣
```

#### 特性

- **优先级支持**：支持包裹优先级排序
- **批量处理**：自动批量处理相同目标格口的包裹
- **线程安全**：基于 `System.Threading.Channels` 实现
- **容量限制**：支持配置队列容量，防止内存溢出

### 3. 并发限流保护

#### 核心组件

- **`ConcurrentSwitchingPathExecutor`**: 带并发控制的路径执行器
- **`SemaphoreSlim`**: 信号量限流

#### 工作原理

```
请求执行 → 获取信号量槽位 → 获取摆轮锁 → 执行路径 → 释放锁 → 释放槽位
```

#### 特性

- **最大并发限制**：限制同时处理的包裹数量
- **队列等待**：超过限制时自动排队等待
- **装饰器模式**：非侵入式包装现有执行器

### 4. 路径调度优化

虽然当前实现了队列的批量处理接口，但路径调度优化（批量处理相同目标的包裹）的完整实现需要在编排层（`ParcelSortingOrchestrator`）中进行集成。当前已提供：

- **批量出队接口**：`DequeueBatchAsync` 方法支持批量获取相同目标的包裹
- **配置开关**：`EnableBatchProcessing` 控制是否启用批量处理
- **批次大小控制**：`MaxBatchSize` 配置最大批次大小

## 配置说明

### 配置文件 (appsettings.json)

```json
{
  "Concurrency": {
    "MaxConcurrentParcels": 10,        // 最大并发包裹处理数量
    "ParcelQueueCapacity": 100,        // 包裹队列容量（-1表示无限制）
    "MaxBatchSize": 5,                 // 批量处理的最大批次大小
    "EnableBatchProcessing": true,     // 是否启用批量处理优化
    "DiverterLockTimeoutMs": 5000      // 摆轮锁等待超时时间（毫秒）
  }
}
```

### 配置项说明

| 配置项 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| MaxConcurrentParcels | int | 10 | 同时处理的包裹数量上限 |
| ParcelQueueCapacity | int | 100 | 队列容量，-1表示无限制 |
| MaxBatchSize | int | 5 | 批量处理时的最大批次大小 |
| EnableBatchProcessing | bool | true | 是否启用批量处理优化 |
| DiverterLockTimeoutMs | int | 5000 | 获取锁的超时时间（毫秒） |

## 集成方式

### 1. 在 Program.cs 中注册服务

```csharp
// 注册并发控制服务
builder.Services.AddConcurrencyControl(builder.Configuration);

// 装饰现有的路径执行器，添加并发控制功能
builder.Services.DecorateWithConcurrencyControl();
```

### 2. 服务自动装饰

系统使用装饰器模式，自动将现有的 `ISwitchingPathExecutor` 实现包装为 `ConcurrentSwitchingPathExecutor`，无需修改现有代码。

## 架构设计

### 装饰器模式

```
MockSwitchingPathExecutor (原执行器)
        ↓
ConcurrentSwitchingPathExecutor (添加并发控制)
        ↓
ISwitchingPathExecutor (接口不变)
```

### 锁获取流程

```
1. 请求执行路径
2. 获取并发槽位（信号量）
3. 按顺序获取路径中每个摆轮的写锁
4. 执行实际路径
5. 逆序释放所有摆轮锁
6. 释放并发槽位
```

### 错误处理

- **获取锁超时**：返回失败结果，包裹发送到异常格口
- **执行被取消**：返回失败结果，包裹发送到异常格口
- **执行异常**：捕获异常，返回失败结果

## 性能影响

### 优势

1. **防止竞态条件**：确保同一摆轮不会被并发控制
2. **提高分拣成功率**：减少因冲突导致的分拣错误
3. **系统稳定性**：限流保护防止系统过载
4. **批量优化潜力**：为批量处理相同目标提供基础

### 开销

1. **锁获取开销**：每个路径需要获取多个摆轮锁（通常 < 10ms）
2. **队列管理开销**：入队/出队操作开销（< 1ms）
3. **信号量开销**：获取/释放信号量开销（< 1ms）

总体性能影响：**单个包裹增加 < 20ms 延迟**，但换来更高的系统稳定性和分拣成功率。

## 监控与调试

### 日志记录

系统在以下关键点记录日志：

```csharp
// 初始化
"初始化并发控制执行器，最大并发数: {MaxConcurrent}"

// 获取槽位
"获取并发槽位成功，目标格口: {TargetChuteId}"

// 获取锁
"获取摆轮 {DiverterId} 的写锁成功"

// 获取锁超时
"获取摆轮 {DiverterId} 的锁超时（{TimeoutMs}ms）"

// 执行完成
"路径执行完成，结果: {Success}，实际格口: {ActualChuteId}"

// 释放锁
"已释放所有摆轮锁"
```

### 性能指标

建议监控以下指标：

1. **平均获取锁时间**：应 < 10ms
2. **锁超时次数**：应接近 0
3. **队列长度**：正常情况下应 < 队列容量的 50%
4. **并发处理数**：应接近 MaxConcurrentParcels 但不超过

## 未来优化方向

1. **动态负载均衡**：根据系统负载动态调整并发限制
2. **批量处理集成**：在编排层完整实现批量处理逻辑
3. **优先级策略**：实现更复杂的包裹优先级策略
4. **性能监控**：添加详细的性能指标收集
5. **自适应调整**：根据历史数据自动调整配置参数

## 常见问题

### Q1: 如何禁用并发控制？

A: 在 Program.cs 中注释掉 `DecorateWithConcurrencyControl()` 调用即可。

### Q2: 获取锁超时怎么办？

A: 增加 `DiverterLockTimeoutMs` 配置值，或检查是否有死锁情况。

### Q3: 队列满了怎么办？

A: 增加 `ParcelQueueCapacity` 配置值，或优化包裹处理速度。

### Q4: 如何调整并发数？

A: 修改 `MaxConcurrentParcels` 配置值，建议根据系统硬件能力设置（CPU 核心数的 2-4 倍）。

### Q5: 批量处理如何使用？

A: 当前已提供队列的批量处理接口，需要在编排层调用 `IParcelQueue.DequeueBatchAsync` 方法来实现批量处理。

## 总结

并发控制机制通过资源锁、队列管理和限流保护三个层面，有效解决了直线摆轮分拣系统的并发冲突问题。该机制设计为非侵入式，易于集成和配置，为系统的高并发场景提供了坚实的保障。
