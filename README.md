# ZakYip.WheelDiverterSorter

[![.NET Build and Test](https://github.com/Hisoka6602/ZakYip.WheelDiverterSorter/actions/workflows/dotnet.yml/badge.svg)](https://github.com/Hisoka6602/ZakYip.WheelDiverterSorter/actions/workflows/dotnet.yml)

直线摆轮分拣系统 - 基于方向控制的包裹自动分拣解决方案

## 📐 系统拓扑结构

本系统采用直线拓扑结构，包裹在传送带上单向流动，通过摆轮转向实现分拣：

```
      格口B     格口D     格口F
        ↑         ↑         ↑
入口 → 摆轮D1 → 摆轮D2 → 摆轮D3 → 末端(默认异常口)
  ↓     ↓         ↓         ↓
传感器  格口A      格口C     格口E
```

### 拓扑说明

- **入口传感器**：检测包裹到达，触发系统创建包裹记录
- **摆轮D1/D2/D3**：每个摆轮前有IO传感器，确认包裹到达并触发转向动作
- **格口A-F**：6个分拣格口，分别位于3个摆轮的左右两侧
- **末端异常口**：包裹直行通过所有摆轮后到达，用于收集异常包裹

### 转向方向定义

摆轮支持三种转向方向（**不使用具体角度**）：

- **直行（Straight）**：包裹继续前进到下一个摆轮
- **左转（Left）**：包裹分流到摆轮左侧格口（图中上方）
- **右转（Right）**：包裹分流到摆轮右侧格口（图中下方）

## ⚠️ 重要说明

本程序和 [ZakYip.Sorting.RuleEngine.Core](https://github.com/Hisoka6602/ZakYip.Sorting.RuleEngine.Core) 是**分开部署**的两个独立程序，互为上下游关系：

- **ZakYip.WheelDiverterSorter（本项目，下游）**：
  - 通过**IO传感器**感应物理包裹并创建包裹记录
  - 向RuleEngine请求格口号
  - 负责**实际执行分拣**动作（控制摆轮）

- **ZakYip.Sorting.RuleEngine.Core（上游）**：
  - 接收包裹ID请求
  - 与**DWS第三方API**通信获取包裹信息（条码、重量、尺寸等）
  - 通过规则引擎决策目标格口号
  - 返回格口号给WheelDiverterSorter

**通信方式：** 两个系统通过**TCP/SignalR/MQTT**等协议通信（多选一）
- ✅ **生产环境推荐**：TCP、SignalR或MQTT（高性能、长连接）
- ❌ **生产环境禁止**：HTTP（仅用于模拟测试，性能不足）

**⚠️ 异常处理策略：**
- 如果**连接不上RuleEngine**，包裹将**默认路由到异常格口**
- 系统会记录连接失败日志，但不会阻塞包裹流转
- 异常格口ID可通过系统配置修改（默认：`CHUTE_EXCEPTION`）

详细的系统关系和集成方案请参阅：[与规则引擎的关系文档](RELATIONSHIP_WITH_RULEENGINE.md)

---

## 项目简介

本项目是一个基于直线摆轮（Wheel Diverter）的包裹自动分拣系统。包裹通过传感器检测进入系统，在输送线上单向移动，经过配置的摆轮节点时，根据转向方向分流到目标格口。系统采用分层架构设计，支持路径规划、执行和可观测性。

### 核心特点

- ✅ **方向控制模式**：摆轮使用左/右/直行方向控制，不依赖具体角度
- ✅ **传感器驱动**：入口和每个摆轮前配置IO传感器，实时跟踪包裹位置
- ✅ **动态配置**：通过LiteDB存储配置，支持运行时热更新
- ✅ **多协议通信**：支持TCP/SignalR/MQTT/HTTP与上游规则引擎通信
- ✅ **推送模型**：格口分配由上游推送，支持超时保护

## 🔄 系统工作流程

### 完整流程（生产环境）

```
1. 包裹入口
   ↓
   入口传感器检测 → 创建包裹ID
   ↓
2. 请求格口分配
   ↓
   通过TCP/SignalR/MQTT向RuleEngine请求格口号
   ↓
   RuleEngine与DWS通信获取包裹信息
   ↓
   RuleEngine决策并返回目标格口ID
   ↓
3. 路径生成
   ↓
   根据目标格口ID生成摆轮转向路径
   例如：格口E需要 [D1:直行, D2:直行, D3:右转]
   ↓
4. 路径执行
   ↓
   包裹到达D1 → D1传感器触发 → 检查路径 → D1执行直行
   ↓
   包裹到达D2 → D2传感器触发 → 检查路径 → D2执行直行
   ↓
   包裹到达D3 → D3传感器触发 → 检查路径 → D3执行右转
   ↓
   包裹分流到格口E
   ↓
5. 完成分拣
```

### 传感器工作逻辑

1. **入口传感器**
   - 检测包裹物理到达
   - 生成唯一包裹ID（基于时间戳）
   - 触发格口分配请求

2. **摆轮前传感器（D1/D2/D3）**
   - 确认包裹到达当前摆轮位置
   - 更新包裹位置状态
   - 触发摆轮执行转向动作
   - 验证包裹是否在TTL时间内到达（超时检测）

3. **传感器特性**
   - 去抖动机制：防止传感器误触发
   - 健康监控：实时监测传感器状态
   - 故障检测：传感器异常时触发告警

### 路径规划逻辑

系统根据目标格口ID，从LiteDB配置中查找摆轮转向序列：

| 目标格口 | 摆轮路径 | 说明 |
|---------|---------|------|
| 格口A | D1:右转 | 直接在第一个摆轮右转 |
| 格口B | D1:左转 | 直接在第一个摆轮左转 |
| 格口C | D1:直行 → D2:右转 | 通过D1后在D2右转 |
| 格口D | D1:直行 → D2:左转 | 通过D1后在D2左转 |
| 格口E | D1:直行 → D2:直行 → D3:右转 | 通过D1、D2后在D3右转 |
| 格口F | D1:直行 → D2:直行 → D3:左转 | 通过D1、D2后在D3左转 |
| 异常口 | D1:直行 → D2:直行 → D3:直行 | 所有摆轮直行，到达末端 |

### 异常处理机制

1. **格口未配置**：目标格口在配置中不存在 → 自动路由到异常口
2. **路径执行超时**：包裹在TTL时间内未到达下一个摆轮 → 路由到异常口
3. **摆轮控制失败**：硬件故障或通信失败 → 路由到异常口
4. **RuleEngine连接失败**：无法获取格口分配 → 默认路由到异常口
5. **传感器故障**：传感器异常时触发告警，包裹继续流转

### 时间控制与超时检测

每个格口配置包含：

- **皮带速度（BeltSpeedMeterPerSecond）**：米/秒
- **皮带长度（BeltLengthMeter）**：从上一检测点到当前格口的距离
- **容差时间（ToleranceTimeMs）**：允许的时间误差范围

系统根据这些参数计算包裹预期到达时间：
```
预期到达时间 = 皮带长度 / 皮带速度 ± 容差时间
```

如果包裹超过 `预期时间 + 容差时间` 仍未到达，则判定为丢包或超时。

---

## 项目结构

- **ZakYip.WheelDiverterSorter.Core**: 核心业务逻辑，包含路径生成器、方向枚举、配置管理
- **ZakYip.WheelDiverterSorter.Execution**: 执行层，包含路径执行器和模拟实现
- **ZakYip.WheelDiverterSorter.Drivers**: 硬件驱动层，包含PLC控制器驱动和IO端口抽象
- **ZakYip.WheelDiverterSorter.Ingress**: 入口管理，传感器驱动、包裹检测、健康监控
- **ZakYip.WheelDiverterSorter.Communication**: 通信层，TCP/SignalR/MQTT/HTTP客户端
- **ZakYip.WheelDiverterSorter.Host**: Web API主机，提供调试接口和配置管理API  
- **ZakYip.WheelDiverterSorter.Observability**: 可观测性支持

---

## 📋 最近更新记录

### 🆕 更新 5: 直线拓扑结构与方向控制重构 (2025-11-13)
- **方向控制替代角度控制**：摆轮从角度控制（0/30/45/90度）改为方向控制（直行/左转/右转）
- **明确拓扑结构**：定义清晰的直线拓扑，3个摆轮，6个格口（每个摆轮左右各一个格口）
- **传感器工作逻辑**：详细说明入口传感器和摆轮前传感器的工作流程
- **路径规划优化**：基于新拓扑结构更新默认格口配置（CHUTE_A到CHUTE_F）
- **文档全面更新**：README.md增加完整的工作流程、时间控制、异常处理说明
- **硬件解耦**：方向到角度转换由硬件驱动层处理，系统逻辑更清晰

### 更新 4: 配置管理增强与热更新支持 (2025-11-13)
- **枚举类型安全**：新增`SensorVendorType`和`DriverVendorType`枚举，替代魔法字符串，提升类型安全
- **LiteDB配置存储**：驱动器、传感器、通信配置全部迁移到LiteDB，支持运行时热更新
- **格口配置增强**：添加皮带速度、皮带长度、容差时间，支持精确的超时检测和丢包判断
- **传感器IO配置**：每个格口配置独立的触发传感器IO，实现实时位置跟踪和动态时间计算
- **新增API端点**：
  - `GET/PUT/RESET /api/config/driver` - 驱动器配置管理
  - `GET/PUT/RESET /api/config/sensor` - 传感器配置管理
  - `GET/PUT/RESET /api/config/communication` - 通信配置管理
- **配置验证**：所有配置增加严格验证逻辑，确保数据一致性和正确性

### 更新 1: 推送模型与类型安全改进 (2025-11-12)
- **推送模型实现**：从请求/响应模型改为推送/回调模型，格口号由上游推送而非主动请求
- **超时保护**：支持格口分配等待超时（默认10秒），超时后自动分配到异常格口
- **类型安全增强**：使用常量类和枚举替代魔法字符串和数字，提高代码可维护性
- **客户端适配**：SignalR/MQTT原生支持推送，TCP/HTTP通过适配器模式支持

详细说明：[推送模型实现总结](IMPLEMENTATION_SUMMARY_PUSH_MODEL.md)

### 更新 2: 并发控制机制 (2025-11-12)
- **摆轮资源锁**：基于读写锁的摆轮资源管理，防止并发冲突
- **包裹队列管理**：优先级队列支持，批量处理相同目标格口的包裹
- **并发限流保护**：可配置的最大并发数，防止系统过载
- **装饰器模式集成**：非侵入式添加并发控制，无需修改现有代码

详细说明：[并发控制机制文档](CONCURRENCY_CONTROL.md)

### 更新 3: 性能优化与基准测试 (2025-11-12)
- **BenchmarkDotNet集成**：完整的性能基准测试套件，测试路径生成和执行性能
- **性能指标收集**：集成.NET标准Metrics API，支持Prometheus/OpenTelemetry导出
- **缓存机制**：路径生成结果缓存，减少重复计算，提升响应速度
- **对象池优化**：使用ArrayPool减少内存分配，降低GC压力

详细说明：[性能优化总结](PERFORMANCE_SUMMARY.md)

---

## 项目当前完成度

**整体完成度：约 92%**

### ✅ 已完成的核心功能

| 模块 | 完成度 | 说明 |
|-----|--------|------|
| 核心路径生成 | 100% | 基于格口到摆轮映射的路径生成，支持LiteDB动态配置和热更新 |
| 配置管理系统 | 100% | 🆕 全面的LiteDB存储，所有热更新配置（驱动器、传感器、通信、路由）均支持API管理和验证 |
| 格口配置系统 | 100% | 🆕 支持皮带速度/长度、容差时间、传感器IO配置，实现精确超时检测 |
| 执行器层 | 100% | 模拟执行器和硬件执行器完整实现，支持配置切换 |
| 通信层 | 100% | TCP/SignalR/MQTT/HTTP客户端全部实现，支持推送模型，与RuleEngine完整集成 |
| 并发控制 | 100% | 摆轮资源锁、包裹队列管理、并发限流保护全部实现 |
| 性能优化 | 95% | 基准测试、性能指标收集、缓存机制、对象池优化已完成 |
| 类型安全 | 100% | 🆕 枚举类型替代字符串，VendorType、CommunicationMode等全面使用枚举 |
| 调试接口 | 100% | HTTP API端点用于测试，集成Swagger文档 |

### 🚧 部分完成的功能

| 模块 | 完成度 | 已完成 | 待完成 |
|-----|--------|--------|--------|
| 硬件驱动层 | 80% | 雷赛控制器驱动、IO端口抽象 | 西门子/三菱/欧姆龙等PLC厂商支持 |
| 传感器系统 | 85% | 雷赛传感器驱动、健康监控、故障检测 | 其他厂商传感器、扫码触发集成 |
| 可观测性 | 50% | 基础日志记录、性能指标收集、传感器健康监控 | Prometheus/Grafana仪表板、OpenTelemetry追踪、告警系统 |
| 测试覆盖 | 15% | 基准性能测试 | 单元测试、集成测试、端到端测试 |

### ❌ 未完成的功能（功能缺失清单）

#### 1. 硬件驱动层缺失
- **多厂商PLC支持**：仅支持雷赛控制器，缺少西门子（Siemens S7系列）、三菱（Mitsubishi FX/Q系列）、欧姆龙（Omron CP/CJ/NJ系列）等主流PLC驱动
- **驱动插件化架构**：缺少动态加载驱动的插件系统，无法运行时切换不同厂商驱动
- **硬件兼容性测试**：缺少不同型号PLC的兼容性测试和验证
- **驱动DLL管理**：原生DLL需手动部署，缺少自动化管理机制

#### 2. 高级路径规划缺失
- **拓扑图建模**：不支持基于拓扑图的路径搜索，当前仅支持硬编码映射
- **动态路径优化**：无法根据设备状态、负载情况动态选择最优路径
- **多路径选择**：不支持备份路径和容错路径
- **路径成本计算**：缺少基于距离、时间、摆轮切换次数的成本优化算法
- **智能调度**：无法考虑设备维护、故障节点自动绕行

#### 3. 生产环境功能缺失
- **Web管理界面**：无可视化管理界面，仅有API接口
- **用户权限管理**：缺少用户认证和授权机制

#### 4. 系统设计说明（不需要实现的功能）
以下功能根据系统架构设计，**不需要在本系统中实现**：
- **扫码触发集成**：❌ 不需要 - 本系统使用IO传感器检测包裹物理到达，不依赖条码扫描
- **供包台关联**：❌ 不需要 - 本系统仅负责分拣执行，与上游RuleEngine通信获取格口号即可
- **包裹历史存储**：❌ 不需要 - 上游RuleEngine已存储包裹数据和历史记录，本系统仅执行分拣
- **数据报表功能**：❌ 不需要 - 报表和统计功能由上游系统负责，本系统专注于分拣执行

**重要架构原则**：
- ✅ 本系统是**纯执行层**，负责根据格口号控制摆轮完成物理分拣
- ✅ **包裹创建**：由IO传感器感应物理包裹到达后创建
- ✅ **格口决策**：由上游RuleEngine负责，本系统通过TCP/SignalR/MQTT通信获取
- ✅ **数据存储**：上游RuleEngine负责持久化，本系统不存储历史数据
- ✅ **异常处理**：如果连接不上RuleEngine，包裹默认路由到异常格口

#### 5. 测试体系缺失
- **单元测试**：核心业务逻辑缺少单元测试覆盖（覆盖率接近0%）
- **集成测试**：缺少模块间集成测试，如路径生成与执行的集成测试
- **端到端测试**：缺少完整流程的E2E测试（从包裹检测到分拣完成）
- **硬件驱动Mock测试**：缺少硬件驱动的模拟测试框架
- **压力测试验证**：未在高并发场景（1000+包裹/分钟）下进行充分测试
- **自动化测试CI/CD**：缺少持续集成的自动化测试流程

#### 6. 可观测性功能缺失
- **Grafana仪表板**：缺少可视化监控面板（分拣成功率、吞吐量、设备状态等）
- **Prometheus集成**：虽有性能指标收集，但未完整集成Prometheus导出器
- **OpenTelemetry追踪**：缺少分布式链路追踪，无法追踪单个包裹的完整处理流程
- **实时告警系统**：缺少钉钉/企业微信/邮件/短信告警集成
- **日志聚合**：缺少ELK/Loki等日志聚合和搜索系统
- **性能分析工具**：缺少APM（Application Performance Monitoring）工具集成

#### 7. 安全性功能缺失
- **API认证授权**：调试接口缺少认证机制，存在安全风险
- **数据加密**：敏感配置数据未加密存储
- **操作审计日志**：缺少配置变更、操作记录的审计功能
- **输入验证增强**：部分API端点的输入验证不够严格

#### 8. 容错和恢复机制缺失
- **故障自动恢复**：设备故障后缺少自动恢复和重试机制
- **数据备份恢复**：缺少配置和数据的备份恢复功能
- **降级策略**：系统部分功能故障时缺少优雅降级机制
- **熔断保护**：缺少对外部依赖（如RuleEngine）的熔断保护（注：已实现连接失败时路由到异常格口）

#### 9. 其他功能缺失
- **多语言支持**：界面和文档仅支持中文，缺少国际化
- **移动端支持**：缺少移动端管理应用
- **API版本管理**：API缺少版本控制机制
- **文档完整性**：部分模块缺少详细的技术文档和操作手册

## 🎯 未来优化方向

> **制定日期**: 2025-11-13  
> **评审周期**: 每季度  
> **总体目标**: 将系统打造成企业级、高可用、高性能的工业分拣解决方案

### 📈 优化路线图总览

```
优先级划分：
P0 - 严重问题，影响系统可用性，需立即解决（1-2周）
P1 - 重要问题，影响系统安全性，需尽快解决（2-4周）
P2 - 中等问题，影响功能完整性，可计划解决（1-2个月）
P3 - 改进项，提升系统质量，可延后解决（2-3个月）
P4 - 优化项，增强用户体验，可选解决（3-6个月）
P5 - 长期规划，技术储备，持续关注（6个月+）
```

### 优先级1：完善测试体系与修复缺陷（高优先级 P0-P1）⏰ 预计 2-3周

**目标**：建立完整的测试体系，保证代码质量和系统稳定性，修复关键缺陷

#### 第一阶段：缺陷修复（P0）⏰ 预计 2-3天
- [ ] **修复集成测试失败**（2小时）
  - 调试`RouteConfigControllerTests`的2个失败用例
  - 修复HTTP状态码返回逻辑
  - 增强测试断言错误信息
- [ ] **启用E2E测试运行**（4小时）
  - 修复E2E测试项目的编译错误
  - 调整Mock设置以兼容可选参数
  - 验证32个E2E测试场景全部通过
- [ ] **验证构建和部署流程**（4小时）
  - 确认所有项目能够成功构建
  - 验证Docker容器化部署
  - 测试配置热更新功能

#### 第二阶段：核心模块单元测试（P0）⏰ 预计 1周
**目标覆盖率**：从14.04% → 60%（+45.96%）

- [ ] **Communication层测试**（2-3天，目标覆盖率>80%）
  - TCP客户端测试：连接、断开、重连、超时
  - SignalR客户端测试：Hub连接、方法调用、回调
  - MQTT客户端测试：发布、订阅、QoS级别
  - HTTP客户端测试：请求、响应、错误处理
  - 通信适配器测试：推送模型、超时保护
  - 预计新增：~50个测试

- [ ] **Execution.Concurrency测试**（1-2天）
  - 并发控制器测试：资源锁、队列管理
  - 优先级队列测试：包裹排序、批处理
  - 死锁检测测试：超时释放、资源争用
  - 预计新增：~30个测试

- [ ] **Observability测试**（0.5天）
  - 指标收集测试：性能指标、业务指标
  - 日志记录测试：结构化日志、日志级别
  - 预计新增：~20个测试

- [ ] **Configuration仓储类测试**（1天）
  - LiteDB仓储测试：CRUD操作、事务
  - 配置验证测试：数据一致性、约束检查
  - 预计新增：~25个测试

#### 第三阶段：集成测试和E2E测试（P1）⏰ 预计 3-4天
**目标**：验证模块间协作和完整业务流程

- [ ] **API端点集成测试补充**（1-2天）
  - CommunicationConfigController测试（5个测试）
  - SensorConfigController测试（5个测试）
  - DebugController测试（3个测试）
  - 预计新增：~15个测试

- [ ] **E2E测试场景扩展**（2天）
  - 高并发场景：100包裹并发分拣
  - 故障恢复场景：RuleEngine断线后重连
  - 配置热更新场景：运行时修改配置
  - 性能压力场景：持续1小时高负载
  - 预计新增：~15个测试

#### 第四阶段：CI/CD集成（P1）⏰ 预计 1-2天
- [x] **配置CI/CD自动测试**
  - GitHub Actions：每次PR自动运行所有测试
  - 测试报告生成：XUnit报告、覆盖率报告
  - 覆盖率门槛检查：最低60%，目标80%
  - 失败时阻止合并

- [ ] **测试覆盖率监控**
  - 集成Codecov或Coverlet
  - 生成覆盖率徽章显示在README
  - 覆盖率趋势图表

**交付成果**：
- ✅ 0个集成测试失败
- ✅ 代码覆盖率 >60%（目标80%）
- ✅ E2E测试全部通过
- ✅ CI/CD自动化测试流程
- ✅ 测试文档和最佳实践指南

### 优先级2：安全性增强（高优先级 P1）⏰ 预计 1-2周

**目标**：建立完整的安全防护体系，通过安全审计

#### 第一阶段：API认证授权（P1）⏰ 预计 3-4天
- [ ] **实现JWT Bearer认证**（1-2天）
  - 配置JWT Token生成和验证
  - 添加登录API端点
  - 所有敏感API端点启用认证
  - Token刷新机制

- [ ] **基于角色的访问控制（RBAC）**（1-2天）
  - 定义角色：Admin、Operator、Viewer
  - 配置权限策略：
    - Admin：所有操作
    - Operator：配置管理、分拣操作
    - Viewer：仅查看监控和配置
  - API端点添加授权检查

- [ ] **API Key认证（备选）**（0.5天）
  - 生成和管理API Key
  - 支持多个Key用于不同客户端
  - Key过期和撤销机制

#### 第二阶段：数据安全（P1）⏰ 预计 2-3天
- [ ] **敏感配置加密**（1天）
  - 使用ASP.NET Core Data Protection
  - 加密存储：数据库连接字符串、API Key、密码
  - 支持密钥轮换

- [ ] **操作审计日志**（1-2天）
  - 记录所有配置变更：谁、何时、改了什么
  - 记录敏感操作：登录、删除配置、系统重启
  - 审计日志持久化（独立存储）
  - 审计日志查询API

#### 第三阶段：输入验证和攻击防护（P1）⏰ 预计 1-2天
- [ ] **增强输入验证**（0.5天）
  - 所有API端点参数严格验证
  - 防止SQL注入（已用LiteDB，风险低）
  - 防止XSS攻击（返回JSON，风险低）

- [ ] **限流保护**（1天）
  - 使用AspNetCoreRateLimit
  - 全局限流：100请求/分钟/IP
  - 敏感端点限流：10请求/分钟/IP
  - 配置API限流：20请求/分钟/用户

- [ ] **生产环境安全配置**（0.5天）
  - 禁用调试端点（/api/debug）
  - HTTPS强制（HSTS）
  - CORS配置严格化
  - 移除敏感信息头

**交付成果**：
- ✅ 完整的认证授权体系
- ✅ 敏感数据加密
- ✅ 操作审计日志
- ✅ 通过基础安全审计

### 优先级3：多厂商硬件支持（高优先级 P2）⏰ 预计 4-6周

**目标**：扩展支持更多PLC厂商，提升系统兼容性和市场竞争力

#### 第一阶段：驱动架构重构（P2）⏰ 预计 1周
- [ ] **设计驱动插件化架构**（3-4天）
  - 定义统一的IDiverterDriver接口
  - 实现驱动发现和加载机制（反射或约定）
  - 支持驱动配置独立管理
  - 驱动版本兼容性检查

- [ ] **重构现有雷赛驱动**（2-3天）
  - 适配新的插件架构
  - 验证向后兼容性
  - 性能测试（确保无退化）

#### 第二阶段：西门子驱动实现（P2）⏰ 预计 1-2周
- [ ] **实现S7-1200/1500驱动**（主要精力）
  - 使用S7.Net.Plus库（开源，活跃维护）
  - 支持以太网通信（S7协议）
  - IO端口读写实现
  - 异常处理和重连机制
  - 单元测试（Mock S7设备）

- [ ] **实现S7-200/300驱动**（如有需求）
  - 使用Sharp7库
  - 适配旧版S7协议

- [ ] **硬件兼容性测试**
  - 在实际S7-1200设备上测试
  - 验证IO读写准确性
  - 压力测试（连续运行24小时）

#### 第三阶段：三菱驱动实现（P2）⏰ 预计 1-2周
- [ ] **实现FX/Q系列驱动**
  - 使用MxComponent或MC协议
  - 支持以太网或串口通信
  - IO端口读写实现
  - 单元测试

- [ ] **硬件兼容性测试**
  - 在实际FX/Q设备上测试

#### 第四阶段：欧姆龙驱动实现（P2）⏰ 预计 1-2周
- [ ] **实现CP/CJ/NJ系列驱动**
  - 使用FINS协议
  - 支持以太网通信
  - IO端口读写实现
  - 单元测试

- [ ] **硬件兼容性测试**
  - 在实际欧姆龙设备上测试

#### 第五阶段：文档和交付（P2）⏰ 预计 3-5天
- [ ] **驱动开发文档**
  - 如何开发新驱动的教程
  - 驱动接口规范
  - 测试指南

- [ ] **硬件兼容性矩阵**
  - 列出支持的所有设备型号
  - 功能支持情况
  - 已知限制和注意事项

- [ ] **用户配置指南**
  - 每个驱动的配置示例
  - 常见问题FAQ

**交付成果**：
- ✅ 插件化驱动架构
- ✅ 支持4种主流PLC厂商（雷赛、西门子、三菱、欧姆龙）
- ✅ 完整的兼容性测试报告
- ✅ 驱动开发和配置文档

### 优先级4：可观测性增强（中优先级 P2-P3）⏰ 预计 2-3周

**目标**：建立完整的监控、告警和追踪体系，提升运维效率

#### 第一阶段：Prometheus和Grafana集成（P2）⏰ 预计 3-4天
- [ ] **Prometheus Exporter集成**（1天）
  - 添加prometheus-net库
  - 暴露/metrics端点
  - 配置Prometheus抓取规则
  - 定义关键指标：
    - 分拣成功/失败计数和比率
    - 包裹吞吐量（每分钟）
    - 路径生成和执行耗时（直方图）
    - 队列长度和等待时间
    - 摆轮状态和使用率
    - RuleEngine连接状态
    - 传感器健康状态

- [ ] **创建Grafana仪表板**（2-3天）
  - 实时监控面板：
    - 核心指标仪表盘（成功率、吞吐量、延迟）
    - 系统健康仪表盘（CPU、内存、连接数）
    - 设备状态仪表盘（摆轮、传感器状态）
    - 业务分析仪表盘（格口分布、路径使用统计）
  - 配置自动刷新和时间范围选择
  - 导出仪表板JSON配置

#### 第二阶段：告警系统实现（P2）⏰ 预计 3-4天
- [ ] **Prometheus AlertManager配置**（1天）
  - 定义告警规则：
    - 分拣失败率 >5%（P1告警）
    - 队列积压 >50包裹（P2告警）
    - 摆轮故障（P1告警）
    - 传感器故障（P2告警）
    - RuleEngine断线 >1分钟（P1告警）
    - 系统重启（P3告警）

- [ ] **钉钉Webhook集成**（1天）
  - 实现钉钉通知发送器
  - 配置告警消息模板
  - 支持告警优先级和分组
  - 测试告警发送

- [ ] **邮件告警集成**（1天）
  - 配置SMTP服务器
  - 实现邮件通知发送器
  - 支持HTML格式告警
  - 支持告警订阅和退订

- [ ] **短信告警集成（可选）**（0.5-1天）
  - 接入阿里云或腾讯云短信API
  - 仅用于P0/P1级别告警
  - 防止短信轰炸（限流）

#### 第三阶段：OpenTelemetry追踪（P3）⏰ 预计 3-4天
- [ ] **集成OpenTelemetry**（2天）
  - 添加OpenTelemetry.Instrumentation包
  - 配置追踪导出器（Jaeger或Zipkin）
  - 自动追踪HTTP请求
  - 自动追踪数据库操作

- [ ] **自定义追踪**（1-2天）
  - 追踪包裹从检测到分拣完成的全流程
  - 追踪与RuleEngine的通信（请求ID传递）
  - 追踪路径生成和执行的每个阶段
  - 追踪摆轮控制操作

- [ ] **分布式追踪可视化**（0.5天）
  - 部署Jaeger UI
  - 验证追踪链路完整性
  - 创建追踪查询教程

#### 第四阶段：日志聚合（P3）⏰ 预计 2-3天
- [ ] **集成Grafana Loki**（1-2天）
  - 配置Loki服务
  - 集成Serilog.Sinks.Loki
  - 配置日志标签（应用、环境、级别）
  - 日志保留策略（30天）

- [ ] **日志查询和分析**（1天）
  - 在Grafana中集成Loki数据源
  - 创建日志查询面板
  - 配置常用日志查询（错误日志、慢查询等）
  - 日志与指标关联（Trace ID）

**交付成果**：
- ✅ 完整的Prometheus+Grafana监控体系
- ✅ 多渠道告警系统（钉钉、邮件、短信）
- ✅ OpenTelemetry分布式追踪
- ✅ 日志聚合和查询
- ✅ 运维监控手册

### 优先级5：高级路径算法（中优先级 P3）⏰ 预计 3-4周

**目标**：实现智能路径规划和优化，提升系统容错能力

#### 第一阶段：拓扑图建模（P3）⏰ 预计 1周
- [ ] **拓扑图数据结构设计**（2-3天）
  - 定义节点类型：摆轮节点、格口节点、入口节点
  - 定义边类型：有向边、权重（距离、时间、成本）
  - 支持拓扑动态加载和验证
  - 拓扑图可视化（导出为Graphviz格式）

- [ ] **拓扑配置管理**（2-3天）
  - 在LiteDB中存储拓扑配置
  - 提供拓扑配置API（CRUD）
  - 拓扑验证：检测环路、孤立节点
  - 拓扑版本管理

- [ ] **拓扑加载和缓存**（1天）
  - 启动时加载拓扑图
  - 拓扑变更时自动刷新
  - 拓扑图内存缓存

#### 第二阶段：路径搜索算法（P3）⏰ 预计 1周
- [ ] **实现Dijkstra最短路径算法**（2-3天）
  - 基于拓扑图计算最短路径
  - 考虑权重因素：距离、时间、摆轮切换次数
  - 单源最短路径和全源最短路径
  - 性能优化（优先队列、路径缓存）

- [ ] **实现A*启发式搜索**（2-3天）
  - 更快的路径搜索（用于复杂拓扑）
  - 定义启发式函数（欧几里得距离）
  - 性能对比测试（与Dijkstra对比）

- [ ] **多路径计算**（1-2天）
  - 计算K条最优路径（K=3）
  - 路径排序和筛选
  - 路径成本评估

#### 第三阶段：设备状态感知（P3）⏰ 预计 3-4天
- [ ] **摆轮状态管理**（1-2天）
  - 维护摆轮实时状态：正常/故障/维护中/降级
  - 状态变更事件和通知
  - 状态持久化

- [ ] **路径生成时状态过滤**（1天）
  - 路径搜索时排除不可用摆轮
  - 仅返回可执行路径
  - 状态变更时自动触发路径重计算

- [ ] **设备健康评分**（1天）
  - 根据历史故障率评分
  - 优先选择健康评分高的路径
  - 评分更新和衰减机制

#### 第四阶段：动态路径重规划（P3）⏰ 预计 3-4天
- [ ] **路径执行失败检测**（1天）
  - 监听路径段执行失败事件
  - 记录失败原因和位置

- [ ] **备用路径计算**（2天）
  - 检测到失败后实时计算备用路径
  - 从当前位置到目标格口的最优路径
  - 备用路径缓存

- [ ] **包裹自动切换路径**（1天）
  - 将包裹切换到备用路径
  - 通知摆轮执行新路径
  - 记录路径切换日志

#### 第五阶段：负载均衡（P3）⏰ 预计 3-4天
- [ ] **摆轮负载统计**（1-2天）
  - 实时统计每个摆轮的使用次数
  - 计算负载率和空闲率
  - 负载数据可视化（Grafana）

- [ ] **负载均衡算法**（2天）
  - 多路径可选时，优先选择负载低的路径
  - 动态调整路径权重
  - 避免热点摆轮过载

- [ ] **性能测试**（0.5天）
  - 验证负载分布均匀性
  - 对比传统路径和负载均衡路径的性能

**交付成果**：
- ✅ 基于拓扑图的路径搜索
- ✅ 设备状态感知和过滤
- ✅ 动态路径重规划
- ✅ 负载均衡算法
- ✅ 高级路径算法文档

### 优先级6：性能验证和优化（中优先级 P3）⏰ 预计 2-3周

**目标**：验证系统性能指标，优化瓶颈，确保达到生产环境要求

#### 第一阶段：性能测试基准建立（P3）⏰ 预计 2-3天
- [ ] **定义关键性能指标（KPI）**（0.5天）
  - 吞吐量：包裹/分钟（目标：500-1000）
  - 延迟指标：
    - 路径生成耗时（目标：<10ms）
    - 路径执行耗时（目标：<100ms/段）
    - 端到端延迟（目标：<500ms）
  - 资源使用：
    - CPU使用率（目标：<70%）
    - 内存使用（目标：<2GB）
    - 网络带宽（目标：<10Mbps）
  - 可靠性：
    - 成功率（目标：>99.5%）
    - 无故障运行时间（MTBF，目标：>720小时）

- [ ] **建立性能测试环境**（1-2天）
  - 模拟生产环境硬件配置
  - 部署完整系统（包括Mock RuleEngine）
  - 配置监控和指标收集
  - 准备测试数据集

#### 第二阶段：高负载场景测试（P3）⏰ 预计 4-5天
- [ ] **500包裹/分钟负载测试**（1-2天）
  - 使用k6或JMeter模拟负载
  - 持续运行1小时
  - 监控所有KPI指标
  - 记录性能数据和瓶颈

- [ ] **1000包裹/分钟负载测试**（1-2天）
  - 相同测试方法
  - 验证系统是否达到目标吞吐量
  - 识别性能极限

- [ ] **性能瓶颈分析**（1天）
  - 使用dotTrace或PerfView分析
  - 识别热点代码路径
  - 分析资源争用情况
  - 生成性能分析报告

#### 第三阶段：压力测试和稳定性测试（P3）⏰ 预计 3-4天
- [ ] **长时间运行测试**（2天）
  - 持续运行8-24小时
  - 恒定负载（500包裹/分钟）
  - 监控内存使用（检测泄漏）
  - 监控CPU和网络

- [ ] **峰值压力测试**（1天）
  - 突发负载：瞬间1500包裹/分钟
  - 测试系统恢复能力
  - 验证限流和队列保护

- [ ] **故障注入测试**（1天）
  - 模拟RuleEngine断线
  - 模拟摆轮故障
  - 模拟网络延迟和丢包
  - 验证系统容错能力

#### 第四阶段：并发性能测试（P3）⏰ 预计 2天
- [ ] **不同并发数测试**（1天）
  - 测试并发数：5、10、20、50
  - 测量吞吐量和延迟
  - 找出最优并发配置

- [ ] **资源锁性能测试**（1天）
  - 测量资源锁争用情况
  - 优化锁粒度
  - 对比读写锁和互斥锁性能

#### 第五阶段：性能优化（P3）⏰ 预计 3-5天
- [ ] **根据测试结果优化瓶颈**
  - 可能的优化点：
    - 增加路径缓存大小或使用分布式缓存（Redis）
    - 优化LiteDB查询（添加索引）
    - 调整并发配置（最大并发数、队列大小）
    - 使用异步IO（数据库、网络）
    - 减少内存分配（对象池、Span<T>）
    - 批量处理（批量路径生成、批量执行）

- [ ] **优化后回归测试**（1天）
  - 重新运行所有性能测试
  - 验证性能提升
  - 确保无功能回归

#### 第六阶段：CI/CD集成（P3）⏰ 预计 1-2天
- [ ] **性能测试自动化**
  - 集成性能测试到CI/CD
  - 每次重要PR运行性能测试
  - 生成性能报告和趋势图

- [ ] **性能回归检测**
  - 对比当前性能与基线
  - 性能退化超过10%时告警
  - 阻止性能回归的合并

**交付成果**：
- ✅ 完整的性能测试报告
- ✅ 性能KPI达标验证
- ✅ 性能优化建议和实施
- ✅ 性能监控和回归检测
- ✅ 性能调优指南

### 优先级7：生产环境功能完善（持续开发 P4）⏰ 预计 4-6周

**目标**：补齐生产环境必需的功能，提升用户体验

#### Web管理界面开发（P4）⏰ 预计 3-4周
- [ ] **前端项目搭建**（2-3天）
  - 技术栈选型：Vue 3 + Element Plus + TypeScript
  - 项目脚手架创建
  - API客户端封装（Axios）
  - 路由和状态管理配置

- [ ] **核心页面开发**（2-3周）
  - 登录页面（1天）
  - 仪表板（3-4天）：实时监控、关键指标
  - 配置管理（5-7天）：
    - 格口路由配置
    - 驱动器配置
    - 传感器配置
    - 通信配置
    - 系统配置
  - 系统监控（3-4天）：
    - 摆轮状态实时显示
    - 传感器健康监控
    - 队列情况可视化
    - RuleEngine连接状态
  - 日志查看（2-3天）：
    - 实时日志流
    - 历史日志查询和过滤
    - 日志导出
  - 告警中心（2-3天）：
    - 当前告警列表
    - 历史告警查询
    - 告警统计和分析

- [ ] **用户权限管理**（3-4天）
  - 用户管理：增删改查
  - 角色管理：Admin、Operator、Viewer
  - 权限配置：页面级别、按钮级别
  - 登录认证集成（JWT）

- [ ] **国际化支持（可选）**（2天）
  - 多语言切换（中文、英文）
  - 使用vue-i18n
  - 翻译所有界面文本

#### 容错和恢复机制完善（P4）⏰ 预计 1周
- [ ] **自动重试机制**（1-2天）
  - 使用Polly库
  - 摆轮控制失败：重试3次，指数退避
  - 传感器读取失败：重试并告警

- [ ] **配置备份恢复**（1-2天）
  - 每天自动备份LiteDB
  - 保留最近7-30天备份
  - 提供配置恢复API和UI

- [ ] **熔断器模式**（1-2天）
  - RuleEngine连接熔断
  - 摆轮控制熔断
  - 熔断状态监控和恢复

- [ ] **状态持久化和恢复**（2-3天）
  - 记录处理中包裹状态
  - 系统重启后自动恢复任务
  - 防止包裹丢失

#### 文档整合和优化（P4）⏰ 预计 1周
- [ ] **文档重组**（3-4天）
  - 合并重复文档
  - 建立文档层次结构
  - 创建文档索引和导航

- [ ] **补充关键文档**（2-3天）
  - 快速开始指南
  - 故障排查手册
  - 运维操作手册
  - 开发贡献指南

- [ ] **在线文档生成（可选）**（1-2天）
  - 使用Docusaurus或VuePress
  - 发布到GitHub Pages
  - 搜索功能集成

**交付成果**：
- ✅ 完整的Web管理界面
- ✅ 用户权限管理系统
- ✅ 完善的容错和恢复机制
- ✅ 整合的文档体系
- ✅ 用户操作手册

### 🗓️ 总体时间线和里程碑

```
阶段1：立即修复（P0-P1）- 2-4周
├─ 周1-2：测试体系完善 + 缺陷修复
├─ 周2-3：安全性增强
└─ 里程碑1：系统可靠性和安全性达标

阶段2：核心功能扩展（P2）- 2-3个月
├─ 月1-1.5：多厂商硬件支持
├─ 月1.5-2：可观测性增强
└─ 里程碑2：生产环境就绪

阶段3：高级功能优化（P3）- 2-3个月
├─ 月1-1.5：高级路径算法
├─ 月1.5-2.5：性能验证和优化
└─ 里程碑3：企业级功能完善

阶段4：体验提升（P4）- 1-2个月
├─ 月1-1.5：Web管理界面
├─ 月1.5-2：文档和培训
└─ 里程碑4：用户体验优化

总计：6-10个月完成所有优化（根据优先级灵活调整）
```

### 📋 资源需求和成本估算

| 阶段 | 人力需求 | 时间 | 关键技能要求 |
|------|---------|------|-------------|
| 测试体系完善 | 1-2人 | 2-3周 | C#、xUnit、Moq |
| 安全性增强 | 1人 | 1-2周 | ASP.NET Core Security、JWT |
| 多厂商硬件支持 | 2-3人 | 4-6周 | PLC协议、工业通信 |
| 可观测性增强 | 1-2人 | 2-3周 | Prometheus、Grafana、OpenTelemetry |
| 高级路径算法 | 1人 | 3-4周 | 算法、图论 |
| 性能验证优化 | 1-2人 | 2-3周 | 性能测试、性能调优 |
| Web管理界面 | 2人 | 3-4周 | Vue.js、前端开发 |
| **总计** | **2-3人团队** | **6-10个月** | **全栈 + 工控背景** |

### ✅ 成功标准和验收条件

#### 功能完整性
- ✅ 支持4种以上PLC厂商（雷赛、西门子、三菱、欧姆龙）
- ✅ 完整的Web管理界面
- ✅ 智能路径规划和动态重规划
- ✅ 完整的监控告警体系

#### 质量指标
- ✅ 代码覆盖率 >80%
- ✅ 所有测试通过，0失败
- ✅ 通过安全审计，0高危漏洞
- ✅ 性能达标：500-1000包裹/分钟，成功率>99.5%

#### 生产就绪
- ✅ 完整的运维文档和培训材料
- ✅ 7x24小时监控和告警
- ✅ 故障恢复时间<5分钟
- ✅ 系统可用性>99.9%

### 📝 持续改进和长期规划（P5）

#### 技术演进
- 微服务架构重构（如需要支持大规模部署）
- 云原生改造（Kubernetes、Service Mesh）
- AI/ML集成（预测性维护、智能优化）

#### 市场拓展
- 多地域部署支持
- SaaS模式改造
- 行业定制版本（快递、电商、制造业）

#### 生态建设
- 开放API平台
- 第三方插件市场
- 社区建设和开源

---

**优化路线图版本**: v1.0  
**制定时间**: 2025-11-13  
**下次评审**: 2026-02-13（3个月后）

---

## 项目结构

- **ZakYip.WheelDiverterSorter.Core**: 核心业务逻辑，包含路径生成器接口和实现
- **ZakYip.WheelDiverterSorter.Execution**: 执行层，包含路径执行器接口和模拟实现
- **ZakYip.WheelDiverterSorter.Drivers**: 🆕 硬件驱动层，包含PLC控制器驱动和IO端口抽象
- **ZakYip.WheelDiverterSorter.Host**: Web API 主机，提供调试接口和配置管理API
- **ZakYip.WheelDiverterSorter.Ingress**: 入口管理（✅ **已完成**：真实传感器和健康监控已实现）
- **ZakYip.WheelDiverterSorter.Observability**: 可观测性支持（待实现）
- **ZakYip.WheelDiverterSorter.Communication**: 通信层（✅ **已完成** 🆕：TCP/SignalR/MQTT/HTTP客户端全部实现）

## 项目运行流程

### 系统启动流程

1. **启动Web API主机**
   ```bash
   cd ZakYip.WheelDiverterSorter.Host
   dotnet run
   ```
   - 默认监听端口：5000（HTTP）
   - 自动注册依赖服务（路径生成器、执行器）

2. **系统初始化**
   - 加载摆轮拓扑配置（当前使用硬编码映射）
   - 初始化路径生成器和执行器
   - 启动Web API监听

### 包裹分拣流程

#### 完整工作流程（生产环境）

```
IO传感器感应 → 创建包裹 → 请求格口号(TCP/SignalR/MQTT) → RuleEngine决策 
→ 接收格口号 → 生成摆轮路径 → 执行路径 → 到达目标格口
```

#### 当前流程（测试环境）

```
手动触发HTTP API → 生成摆轮路径 → 执行路径 → 到达目标格口
```

#### 详细步骤说明

1. **包裹入口**
   - **生产模式（待实现）**：
     - IO传感器感应包裹到达
     - 自动创建包裹记录并生成包裹ID
     - 通过TCP/SignalR/MQTT向RuleEngine.Core请求格口号
     - RuleEngine与DWS第三方API通信获取包裹信息
     - RuleEngine返回目标格口ID
   - **调试模式（当前实现）**：
     - 通过HTTP API手动触发 `POST /api/debug/sort`
     - 直接提供包裹ID和目标格口ID
     - ⚠️ 此模式仅用于测试，生产环境禁用HTTP

2. **路径生成阶段** (`ISwitchingPathGenerator`)
   - 接收包裹ID和目标格口ID
   - 查询格口到摆轮的映射关系
   - 生成有序的摆轮路径段列表（`SwitchingPath`）
   - 每段包含：摆轮ID、目标角度、TTL（超时时间）
   - 如果格口未配置，返回null，包裹将走异常口

3. **路径执行阶段** (`ISwitchingPathExecutor`)
   - 按顺序执行每个路径段
   - 模拟执行器：模拟设备响应延迟
   - 真实执行器（待实现）：与PLC/设备通信，控制摆轮角度
   - 监控每段的TTL，超时则标记失败

4. **结果反馈**
   - 执行成功：返回目标格口ID
   - 执行失败：返回异常格口ID和失败原因
   - 记录执行日志供后续分析

## 工作原理

### 核心概念

#### 1. 摆轮（Wheel Diverter）

摆轮是安装在直线输送线上的分拣设备，通过旋转不同角度将包裹分流到不同方向：

- **0度**：包裹直行通过
- **30度/45度**：小角度分流（常用于相邻格口）
- **90度**：大角度分流（常用于垂直分拣）

#### 2. 直线拓扑结构

```
入口 → 摆轮D1 → 摆轮D2 → 摆轮D3 → 末端
        ↓         ↓         ↓
     格口B      格口A     格口C
```

包裹在输送线上单向移动，经过配置的摆轮节点时，根据路径指令分流到目标格口。

#### 3. 路径规划

**当前实现（硬编码映射）**：
```csharp
// 格口A：需要经过摆轮D1（30度）和摆轮D2（45度）
"CHUTE_A" -> [D1:30°, D2:45°]

// 格口B：需要经过摆轮D1（0度直行）
"CHUTE_B" -> [D1:0°]

// 格口C：需要经过摆轮D1（90度）和摆轮D3（30度）
"CHUTE_C" -> [D1:90°, D3:30°]
```

**未来实现（基于拓扑的动态路径搜索）**：
- 从拓扑模型 (`SorterTopology`) 自动计算最优路径
- 支持多条路径选择和负载均衡
- 考虑设备状态和故障节点

#### 4. 路径段与TTL

每个路径段包含：
- **摆轮ID**：指定哪个摆轮执行动作
- **目标角度**：摆轮应旋转到的角度
- **TTL（Time To Live）**：该段的最大执行时间（默认5000ms）

如果段执行超过TTL，视为失败，包裹将被引导到异常格口。

#### 5. 异常处理机制

- **路径生成失败**：目标格口未配置 → 返回null → 包裹走异常口
- **路径执行失败**：段超时或设备故障 → 返回失败结果 → 包裹走异常口
- **异常格口**：默认为 `CHUTE_EXCEPTION`，用于收集所有异常包裹

## 调试接口

### 概述

Host 层提供了一个用于调试直线摆轮方案的最小接口。

**注意**：这是调试入口，生产环境应使用IO传感器触发包裹检测。

### API 端点

**POST** `/api/debug/sort`

#### 请求参数

```json
{
  "parcelId": "包裹ID",
  "targetChuteId": "目标格口ID"
}
```

#### 响应示例

成功案例（格口E）：
```json
{
  "parcelId": "PKG001",
  "targetChuteId": "CHUTE_E",
  "isSuccess": true,
  "actualChuteId": "CHUTE_E",
  "message": "分拣成功：包裹 PKG001 已成功分拣到格口 CHUTE_E",
  "failureReason": null,
  "pathSegmentCount": 3
}
```

失败案例（未知格口）：
```json
{
  "parcelId": "PKG004",
  "targetChuteId": "CHUTE_UNKNOWN",
  "isSuccess": false,
  "actualChuteId": "未知",
  "message": "路径生成失败：目标格口无法映射到任何摆轮组合",
  "failureReason": "目标格口未配置或不存在",
  "pathSegmentCount": 0
}
```

### 使用示例

测试格口A（D1右转）：
```bash
curl -X POST http://localhost:5000/api/debug/sort \
  -H "Content-Type: application/json" \
  -d '{"parcelId": "PKG001", "targetChuteId": "CHUTE_A"}'
```

测试格口E（D1直行→D2直行→D3右转）：
```bash
curl -X POST http://localhost:5000/api/debug/sort \
  -H "Content-Type: application/json" \
  -d '{"parcelId": "PKG002", "targetChuteId": "CHUTE_E"}'
```

### 工作流程

1. 接收包裹ID和目标格口ID
2. 调用路径生成器（`ISwitchingPathGenerator`）生成 `SwitchingPath`
3. 调用执行器（`ISwitchingPathExecutor`）执行路径
4. 返回执行结果和实际落格ID

### 预配置的格口

当前默认配置包含以下6个格口（基于直线拓扑结构）：

| 格口ID | 位置 | 路径配置 | 说明 |
|--------|------|---------|------|
| **CHUTE_A** | D1右侧 | D1:右转 | 最近的格口，包裹在第一个摆轮即分流 |
| **CHUTE_B** | D1左侧 | D1:左转 | 第一个摆轮左侧格口 |
| **CHUTE_C** | D2右侧 | D1:直行 → D2:右转 | 需通过D1才能到达 |
| **CHUTE_D** | D2左侧 | D1:直行 → D2:左转 | 第二个摆轮左侧格口 |
| **CHUTE_E** | D3右侧 | D1:直行 → D2:直行 → D3:右转 | 最远的右侧格口 |
| **CHUTE_F** | D3左侧 | D1:直行 → D2:直行 → D3:左转 | 最远的左侧格口 |

**拓扑示意图**：
```
      格口B     格口D     格口F
        ↑         ↑         ↑
入口 → 摆轮D1 → 摆轮D2 → 摆轮D3 → 末端(异常口)
        ↓         ↓         ↓
     格口A      格口C     格口E
```

**注意**: 这些配置存储在 LiteDB 数据库中，可以通过配置管理 API 动态修改。

### 路径配置示例

#### 示例 1: 格口A（简单路径）
```json
{
  "chuteId": "CHUTE_A",
  "chuteName": "格口A（D1右侧）",
  "diverterConfigurations": [
    {
      "diverterId": "D1",
      "targetDirection": "Right",
      "sequenceNumber": 1
    }
  ],
  "beltSpeedMeterPerSecond": 1.5,
  "beltLengthMeter": 5.0,
  "toleranceTimeMs": 2000,
  "isEnabled": true
}
```

#### 示例 2: 格口E（复杂路径）
```json
{
  "chuteId": "CHUTE_E",
  "chuteName": "格口E（D3右侧）",
  "diverterConfigurations": [
    {
      "diverterId": "D1",
      "targetDirection": "Straight",
      "sequenceNumber": 1
    },
    {
      "diverterId": "D2",
      "targetDirection": "Straight",
      "sequenceNumber": 2
    },
    {
      "diverterId": "D3",
      "targetDirection": "Right",
      "sequenceNumber": 3
    }
  ],
  "beltSpeedMeterPerSecond": 1.5,
  "beltLengthMeter": 15.0,
  "toleranceTimeMs": 2000,
  "isEnabled": true
}
```

## 配置管理 API

系统提供了完整的 RESTful API 用于动态管理所有配置，支持热更新（无需重启）。所有频繁变动的配置已从 appsettings.json 迁移到 LiteDB 数据库。

### 主要功能

- ✅ **动态配置管理**: 通过 API 添加、修改、删除各类配置
- ✅ **热更新支持**: 配置更改立即生效，无需重启应用
- ✅ **数据持久化**: 使用 LiteDB 存储配置数据
- ✅ **配置验证**: 自动验证配置的正确性和完整性
- ✅ **类型安全**: 使用枚举类型，避免魔法字符串和数字

### API 端点总览

#### 1️⃣ 格口路由配置

| 方法 | 端点 | 说明 |
|------|------|------|
| GET | `/api/config/routes` | 获取所有路由配置 |
| GET | `/api/config/routes/{chuteId}` | 获取指定格口配置 |
| POST | `/api/config/routes` | 创建新的路由配置 |
| PUT | `/api/config/routes/{chuteId}` | 更新路由配置（热更新） |
| DELETE | `/api/config/routes/{chuteId}` | 删除路由配置 |

#### 2️⃣ 驱动器配置 🆕

| 方法 | 端点 | 说明 |
|------|------|------|
| GET | `/api/config/driver` | 获取驱动器配置 |
| PUT | `/api/config/driver` | 更新驱动器配置（热更新） |
| POST | `/api/config/driver/reset` | 重置为默认配置 |

#### 3️⃣ 传感器配置 🆕

| 方法 | 端点 | 说明 |
|------|------|------|
| GET | `/api/config/sensor` | 获取传感器配置 |
| PUT | `/api/config/sensor` | 更新传感器配置（热更新） |
| POST | `/api/config/sensor/reset` | 重置为默认配置 |

#### 4️⃣ 通信配置 🆕

| 方法 | 端点 | 说明 |
|------|------|------|
| GET | `/api/config/communication` | 获取通信配置 |
| PUT | `/api/config/communication` | 更新通信配置（热更新） |
| POST | `/api/config/communication/reset` | 重置为默认配置 |

#### 5️⃣ 系统配置

| 方法 | 端点 | 说明 |
|------|------|------|
| GET | `/api/config/system` | 获取系统配置 |
| PUT | `/api/config/system` | 更新系统配置（热更新） |
| POST | `/api/config/system/reset` | 重置为默认配置 |

### 配置示例

#### 示例 1: 创建格口配置（基于方向控制）

```bash
curl -X POST http://localhost:5000/api/config/routes \
  -H "Content-Type: application/json" \
  -d '{
    "chuteId": "CHUTE_E",
    "chuteName": "格口E（D3右侧）",
    "diverterConfigurations": [
      {"diverterId": "D1", "targetDirection": "Straight", "sequenceNumber": 1},
      {"diverterId": "D2", "targetDirection": "Straight", "sequenceNumber": 2},
      {"diverterId": "D3", "targetDirection": "Right", "sequenceNumber": 3}
    ],
    "beltSpeedMeterPerSecond": 1.5,
    "beltLengthMeter": 15.0,
    "toleranceTimeMs": 2000,
    "sensorConfig": {
      "sensorId": "SENSOR_CHUTE_E_01",
      "sensorType": "Photoelectric",
      "inputBit": 8,
      "isEnabled": true,
      "debounceTimeMs": 100
    },
    "isEnabled": true
  }'
```

**说明**：
- `targetDirection` 可选值：`"Straight"`, `"Left"`, `"Right"`
- 格口E需要包裹通过D1和D2后，在D3右转到达
- 传感器配置用于检测包裹到达D3位置

#### 示例 2: 更新驱动器配置

```bash
curl -X PUT http://localhost:5000/api/config/driver \
  -H "Content-Type: application/json" \
  -d '{
    "useHardwareDriver": true,
    "vendorType": 1,
    "leadshine": {
      "cardNo": 0,
      "diverters": [
        {"diverterId": "D1", "outputStartBit": 0, "feedbackInputBit": 10},
        {"diverterId": "D2", "outputStartBit": 2, "feedbackInputBit": 11}
      ]
    }
  }'
```

#### 示例 3: 更新通信配置

```bash
curl -X PUT http://localhost:5000/api/config/communication \
  -H "Content-Type: application/json" \
  -d '{
    "mode": 1,
    "tcpServer": "192.168.1.100:8000",
    "timeoutMs": 5000,
    "retryCount": 3,
    "enableAutoReconnect": true
  }'
```

**说明**：
- `mode`: 0=Http, 1=Tcp, 2=SignalR, 3=Mqtt
- `vendorType`: 0=Mock, 1=Leadshine, 2=Siemens, 3=Mitsubishi, 4=Omron
- 所有配置更新后立即生效，无需重启服务

详细的 API 文档请参阅：[配置管理 API 文档](CONFIGURATION_API.md)

## 运行项目

```bash
cd ZakYip.WheelDiverterSorter.Host
dotnet run
```

默认监听端口：5000（HTTP）

## ⚠️ 当前风险与缺陷

> **文档更新日期**: 2025-11-13  
> **项目状态**: 构建成功 ✅ | 测试通过率: 97.9% (91/93) | 代码覆盖率: 14.04% ⚠️

### 📊 项目健康度总览

| 指标 | 当前值 | 目标值 | 状态 |
|------|--------|--------|------|
| 构建状态 | ✅ 成功 | ✅ 成功 | 达标 |
| 单元测试通过率 | 97.9% (91/93) | 100% | 🟡 接近达标 |
| 代码覆盖率 | 14.04% | >80% | 🔴 严重不足 |
| 集成测试失败 | 2个 | 0个 | 🔴 需修复 |
| 硬件厂商支持 | 1个(雷赛) | 4+个 | 🟡 需扩展 |
| 文档完整性 | 30+个MD文件 | 集中化 | 🟡 需整合 |
| API安全性 | 无认证 | 完整认证 | 🔴 严重缺失 |

### ✅ 已解决的问题 (2025-11-13更新)

#### 1. 配置热更新问题 - ✅ 已解决
- **原问题**：驱动器、传感器、通信等配置写死在appsettings.json中，修改需要重启服务
- **解决方案**：全部迁移到LiteDB数据库，提供API端点进行热更新
- **影响**：✅ 现在可以在运行时动态修改配置，无需重启，大幅提升运维效率

#### 2. 类型安全问题 - ✅ 已解决
- **原问题**：VendorType使用字符串类型，容易拼写错误，缺少编译时检查
- **解决方案**：引入`SensorVendorType`和`DriverVendorType`枚举类型
- **影响**：✅ 编译时类型检查，避免运行时错误，代码更安全

#### 3. 超时检测缺失 - ✅ 已解决
- **原问题**：格口配置缺少容差时间，无法精确判断包裹超时或丢失
- **解决方案**：为每个格口添加皮带速度、皮带长度、容差时间配置
- **影响**：✅ 系统可以精确计算预期到达时间，准确检测超时和丢包

#### 4. 传感器IO配置缺失 - ✅ 已解决
- **原问题**：格口前传感器IO未配置，无法实时跟踪包裹位置
- **解决方案**：为每个格口添加独立的传感器IO配置（ChuteSensorConfig）
- **影响**：✅ 可以实时追踪包裹位置，动态计算到达下一格口的时间

### 🔴 高风险项（需尽快解决）

#### 1. 测试覆盖率严重不足 ⚠️ **优先级：P0**
- **问题详情**：
  - 当前代码覆盖率：14.04%（目标：>80%，差距：65.96%）
  - 测试状态：93个测试，2个集成测试失败
  - 具体失败测试：
    - `RouteConfigControllerTests.GetRoute_WithValidChuteId_ReturnsSuccess`
    - `RouteConfigControllerTests.DeleteRoute_WithChuteId_ReturnsSuccess`
  - 测试分布：Core(77个) ✅, Host.Integration(12个, 2失败) ⚠️, Drivers(8个) ✅, Ingress(8个) ✅
  - E2E测试项目存在但未运行（ZakYip.WheelDiverterSorter.E2ETests）
- **缺失测试模块**：
  - Communication层：0个测试（TCP/SignalR/MQTT/HTTP客户端未测试）
  - Execution.Concurrency：0个测试（并发控制未测试）
  - Observability：0个测试（可观测性未测试）
  - 真实硬件执行器：仅Mock测试，无真实场景测试
- **风险**：
  - 代码重构时易引入回归缺陷，无法快速发现
  - 并发控制、通信层等关键模块未经验证
  - 生产环境部署风险高，故障难以预防
- **影响**：
  - 系统稳定性无法保证
  - 维护成本高，每次改动需要大量手工测试
  - 难以满足工业级生产环境的可靠性要求
- **建议行动**：
  1. **立即修复失败的集成测试**（预计：2小时）
  2. **补充核心模块单元测试**，优先级顺序：
     - Communication层测试（预计：1-2天，目标覆盖率>80%）
     - Execution.Concurrency测试（预计：1天）
     - Observability测试（预计：0.5天）
  3. **启用E2E测试运行**（预计：0.5天）
  4. **建立CI/CD强制覆盖率检查**（最低60%，目标80%）
  5. **每周增量提升覆盖率5-10%**，4-6周内达标

#### 2. 集成测试失败 ⚠️ **优先级：P0**
- **问题详情**：
  - 失败测试1：`GetRoute_WithValidChuteId_ReturnsSuccess`
    - 位置：`RouteConfigControllerTests.cs:51`
    - 错误：断言失败，期望True，实际False
    - 可能原因：API端点返回状态码不符合预期（非200或404）
  - 失败测试2：`DeleteRoute_WithChuteId_ReturnsSuccess`
    - 位置：`RouteConfigControllerTests.cs:125`
    - 错误：断言失败，期望True，实际False
    - 可能原因：删除操作返回状态码异常
- **风险**：
  - 路由配置API不稳定，可能影响配置管理功能
  - 测试失败表明API行为与预期不一致
- **建议行动**：
  1. 调试测试用例，确认实际返回的HTTP状态码
  2. 修复RouteConfigController的响应逻辑
  3. 增强测试断言，提供更详细的错误信息

#### 3. API安全性严重缺失 ⚠️ **优先级：P1**
- **问题详情**：
  - 所有API端点无认证机制，任何人可访问
  - 敏感配置端点（如驱动器配置、通信配置）完全开放
  - 调试端点`/api/debug/sort`在生产环境可访问
  - appsettings.json包含敏感信息（IP地址、端口等），未加密
  - 无操作审计日志，无法追踪配置变更记录
- **潜在安全风险**：
  - 未授权访问：恶意用户可修改系统配置
  - 配置篡改：摆轮路径、驱动器参数可被恶意修改，导致分拣错误
  - 数据泄露：系统拓扑、设备信息暴露
  - 拒绝服务：恶意请求可导致系统过载
- **影响**：
  - 生产环境安全风险高，无法通过安全审计
  - 违反工业控制系统安全标准
- **建议行动**：
  1. **立即实现API认证**（JWT Bearer或API Key）
  2. **配置敏感数据加密**（使用ASP.NET Core Data Protection）
  3. **添加授权策略**（基于角色的访问控制RBAC）
  4. **实现审计日志**（记录所有配置变更和敏感操作）
  5. **生产环境禁用调试端点**（通过环境变量控制）
  6. **限流保护**（使用AspNetCoreRateLimit）

#### 4. 多厂商硬件支持不足 ⚠️ **优先级：P2**
- **问题详情**：
  - 当前仅支持：雷赛（Leadshine）控制器
  - 缺失主流厂商：
    - 西门子（Siemens）：S7-200/300/1200/1500系列
    - 三菱（Mitsubishi）：FX/Q/L系列
    - 欧姆龙（Omron）：CP/CJ/NJ系列
  - 驱动架构不够灵活，缺少插件化机制
  - 无厂商驱动热插拔支持
- **限制场景**：
  - 无法在使用西门子PLC的欧洲工厂部署
  - 无法支持使用三菱PLC的日本客户
  - 现场更换PLC时需要重新开发
- **影响**：
  - 市场竞争力受限，失去多厂商客户
  - 部署灵活性差，增加客户定制成本
- **建议行动**：
  1. **设计驱动插件化架构**（预计：3-4天）
     - 定义IDiverterDriver接口标准
     - 实现驱动发现和加载机制
     - 支持运行时驱动切换
  2. **实现西门子S7驱动**（预计：1-2周）
     - 使用S7.Net或Sharp7库
     - 支持S7-1200/1500（最常用）
  3. **实现三菱FX/Q驱动**（预计：1-2周）
     - 使用MxComponent或MC协议
  4. **实现欧姆龙CP/CJ驱动**（预计：1-2周）
     - 使用FINS协议
  5. **建立硬件兼容性测试矩阵**
  6. **文档化每个驱动的配置和限制**

#### 5. 系统架构已确认 ℹ️ **说明**
- **以下功能根据架构设计不需要在本系统实现**：
  - ❌ **扫码触发集成**：使用IO传感器检测物理包裹，不依赖条码扫描
  - ❌ **供包台接口**：与上游RuleEngine通信获取格口号即可
  - ❌ **包裹历史存储**：上游RuleEngine负责持久化和历史查询
  - ❌ **数据报表功能**：报表和统计分析由上游系统提供
  - ❌ **包裹信息查询**：本系统仅执行分拣，不存储包裹详细信息
- **架构定位**：
  - ✅ 本系统是**纯执行层**，专注于根据格口号控制摆轮完成物理分拣
  - ✅ **包裹检测**：由IO传感器感应物理到达后创建临时记录
  - ✅ **格口决策**：由上游RuleEngine负责，通过TCP/SignalR/MQTT通信获取
  - ✅ **异常处理**：连接不上RuleEngine时，包裹默认路由到异常格口
- **影响**：✅ 系统定位明确，专注核心功能，降低复杂度
- **建议**：保持当前清晰的架构边界，避免功能蔓延

### 🟡 中风险项（影响运维和优化）

#### 6. 可观测性功能不完整 ⚠️ **优先级：P2**
- **当前状态**：
  - ✅ 已实现：基础日志记录（ILogger）
  - ✅ 已实现：性能指标收集（.NET Metrics API）
  - ✅ 已实现：传感器健康监控
  - ⚠️ 部分实现：Prometheus指标暴露（代码存在但未完全集成）
- **缺失功能**：
  - ❌ **Grafana仪表板**：无可视化监控界面
    - 缺少实时分拣成功率图表
    - 缺少包裹吞吐量监控
    - 缺少摆轮状态热力图
    - 缺少队列长度和延迟监控
  - ❌ **完整告警系统**：
    - 无钉钉/企业微信集成
    - 无邮件告警
    - 无短信告警
    - 仅有日志记录，无主动通知
  - ❌ **分布式追踪**：
    - 无OpenTelemetry集成
    - 无法追踪单个包裹的完整分拣流程
    - 跨系统调用链不可见（与RuleEngine通信）
  - ❌ **日志聚合**：
    - 无ELK Stack集成
    - 无Loki/Grafana Loki集成
    - 日志分散，难以统一查询和分析
  - ❌ **APM工具**：
    - 无Application Insights集成
    - 无性能瓶颈分析工具
- **风险**：
  - 生产环境故障发现延迟，MTTR（平均修复时间）长
  - 无法实时监控系统健康度
  - 性能问题难以定位和优化
- **影响**：
  - 运维效率低，依赖手工检查
  - 故障响应慢，可能导致生产中断
  - 无法进行精细化性能调优
- **建议行动**：
  1. **集成Prometheus Exporter**（预计：1天）
     - 暴露指标端点：`/metrics`
     - 配置Prometheus抓取
  2. **创建Grafana监控仪表板**（预计：2-3天）
     - 实时分拣成功率和失败率
     - 包裹吞吐量（每分钟）
     - 摆轮状态和利用率
     - 队列长度和等待时间
     - RuleEngine连接状态
     - 传感器健康状态
  3. **实现告警系统**（预计：2-3天）
     - 钉钉Webhook集成（高优先级）
     - 邮件告警（SMTP）
     - 短信告警（可选，接入阿里云/腾讯云短信API）
     - 告警规则：分拣失败率>5%、队列积压>50、传感器故障等
  4. **集成OpenTelemetry追踪**（预计：2-3天）
     - 追踪包裹从检测到分拣完成的全流程
     - 追踪与RuleEngine的通信延迟
     - 追踪摆轮执行时间
  5. **配置日志聚合**（预计：1-2天）
     - 推荐Loki（轻量级，与Grafana集成好）
     - 配置日志标签和过滤

#### 7. 路径算法功能受限 ⚠️ **优先级：P3**
- **当前实现**：
  - ✅ 基于直接映射：格口ID → 摆轮转向序列（硬编码或LiteDB配置）
  - ✅ 路径缓存：减少重复计算
  - ✅ TTL超时检测：每段路径有时间限制
- **功能限制**：
  - ❌ 不考虑设备实时状态（摆轮故障、维护中）
  - ❌ 不考虑负载均衡（多条路径可达时无优化）
  - ❌ 无备份路径支持（主路径失败后无Plan B）
  - ❌ 无动态路径重规划（设备故障时无法自动绕行）
  - ❌ 未实现基于拓扑图的路径搜索算法（Dijkstra/A*）
- **受限场景**：
  - 摆轮D2故障 → 所有需要经过D2的格口（C、D、E、F）都不可达 → 包裹全部走异常口
  - 摆轮D1维护中 → 所有包裹无法分拣
  - 多条路径可达同一格口时，无法根据摆轮负载选择最优路径
- **风险**：
  - 设备故障时系统容错能力差
  - 维护窗口期间分拣效率低
  - 无法处理复杂拓扑结构
- **影响**：
  - 系统可用性降低
  - 分拣效率不够理想
  - 扩展到更复杂拓扑时需要重构
- **建议行动**：
  1. **建立拓扑图模型**（预计：3-4天）
     - 定义节点（摆轮、格口）和边（连接关系）
     - 支持拓扑配置的动态加载
  2. **实现路径搜索算法**（预计：3-5天）
     - Dijkstra算法：计算最短路径
     - 考虑成本因素：摆轮切换次数、距离、负载
     - 多路径支持：计算N条可选路径
  3. **设备状态感知**（预计：2-3天）
     - 维护摆轮实时状态（正常/故障/维护中）
     - 路径生成时排除不可用摆轮
     - 支持摆轮临时禁用
  4. **动态路径重规划**（预计：2-3天）
     - 检测到路径执行失败时触发
     - 实时计算备用路径
     - 包裹自动切换到备用路径
  5. **负载均衡算法**（预计：2-3天）
     - 跟踪每个摆轮的使用频率
     - 多路径可选时，优先选择负载低的路径

#### 8. 性能验证不充分 ⚠️ **优先级：P3**
- **当前状态**：
  - ✅ 已有性能优化：缓存、对象池、并发控制
  - ✅ 已有Benchmark项目：测试路径生成和执行性能
  - ✅ 已有k6脚本：HTTP API负载测试
  - ⚠️ 未集成到CI/CD
- **验证缺失**：
  - ❌ **高负载场景测试**：
    - 目标：500-1000包裹/分钟
    - 未在实际负载下验证
    - 不确定系统瓶颈在哪里
  - ❌ **压力测试**：
    - 无持续高负载测试（如运行8小时）
    - 无内存泄漏检测
    - 无长时间运行稳定性验证
  - ❌ **并发测试**：
    - 虽有并发控制代码，但未充分测试
    - 最大并发数10是否够用未验证
    - 资源锁性能影响未量化
  - ❌ **网络延迟测试**：
    - 与RuleEngine通信延迟影响未测试
    - 超时重试机制性能影响未验证
  - ❌ **性能回归检测**：
    - 每次代码变更后无自动性能对比
    - 可能引入性能退化而不自知
- **风险**：
  - 生产环境可能出现性能瓶颈
  - 无法保证目标吞吐量（500-1000包裹/分钟）
  - 性能问题在上线后才发现，代价高
- **影响**：
  - 系统容量规划不准确
  - 可能需要硬件过度配置
  - 客户满意度受影响
- **建议行动**：
  1. **建立性能测试基准**（预计：2-3天）
     - 定义关键性能指标（KPI）：
       - 吞吐量：包裹/分钟
       - 延迟：路径生成耗时、执行耗时
       - 资源使用：CPU、内存、网络
     - 设定性能目标和阈值
  2. **高负载场景测试**（预计：3-4天）
     - 模拟500包裹/分钟负载
     - 模拟1000包裹/分钟负载
     - 监控系统资源使用
     - 识别性能瓶颈
  3. **压力测试和稳定性测试**（预计：2-3天）
     - 持续运行8小时以上
     - 监控内存使用，检测泄漏
     - 验证长时间运行稳定性
  4. **并发性能测试**（预计：1-2天）
     - 测试不同并发数（5、10、20、50）
     - 测量资源锁争用情况
     - 优化并发配置
  5. **集成性能测试到CI/CD**（预计：1-2天）
     - 每次PR自动运行性能测试
     - 生成性能报告
     - 性能回归时自动告警
  6. **优化瓶颈**（根据测试结果）
     - 可能的优化点：
       - 增加路径缓存大小
       - 优化数据库查询
       - 调整并发配置
       - 使用异步IO

#### 9. TTL计算待优化 ⚠️ **优先级：P3**
- **当前状态**：
  - ✅ 格口配置支持：皮带速度、皮带长度、容差时间
  - ✅ 格口级别超时检测：精确计算预期到达时间
  - ⚠️ 路径段TTL：使用固定值5000ms，未动态计算
- **待改进**：
  - 路径段TTL未与格口配置集成
  - 无法根据实际皮带速度和长度动态调整
  - 固定TTL可能过长（浪费时间）或过短（误判超时）
- **影响**：
  - 超时检测不够精确
  - 可能误判包裹超时或过晚检测
- **建议**：
  - 将格口配置的时间计算逻辑应用到路径段TTL
  - 每个路径段动态计算TTL = 距离 / 速度 + 容差
  - 实现端到端的动态时间管理

### 🟢 低风险项（改进项）

#### 10. 硬件DLL管理不便 ⚠️ **优先级：P4**
- **问题**：
  - 雷赛LTDMC.dll等原生DLL需要手动复制到输出目录
  - 无版本管理和校验机制
  - 不同版本DLL可能导致兼容性问题
  - Docker部署时需要额外处理DLL
- **影响**：
  - 部署复杂度增加
  - 容易遗漏DLL或版本不匹配
  - CI/CD自动化困难
- **建议行动**：
  1. **NuGet包化**：将常用DLL打包为NuGet包
  2. **版本检查**：启动时检查DLL版本
  3. **Docker镜像预装**：在Docker镜像中预装所有DLL
  4. **部署脚本**：提供自动化部署脚本

#### 11. Web管理界面缺失 ⚠️ **优先级：P4**
- **问题**：
  - 仅有RESTful API端点，无图形化界面
  - 配置管理需要使用Postman或curl
  - 实时监控依赖日志查看
  - 学习曲线陡峭，非技术人员难以使用
- **影响**：
  - 运维人员使用体验差
  - 培训成本高
  - 故障排查效率低
- **建议行动**：
  1. **前端技术选型**：
     - 推荐：Vue 3 + Element Plus（快速开发）
     - 备选：React + Ant Design
  2. **核心功能页面**（预计：2-3周）：
     - 仪表板：实时分拣状态、吞吐量、成功率
     - 配置管理：格口路由、驱动器、传感器、通信配置
     - 系统监控：摆轮状态、传感器健康、队列情况
     - 日志查看：实时日志流、历史日志查询
     - 告警中心：当前告警、历史告警、告警统计
  3. **权限管理**：
     - 只读用户：仅查看监控和配置
     - 操作用户：可修改配置
     - 管理员：完全权限

#### 12. 容错和恢复机制待完善 ⚠️ **优先级：P4**
- **当前状态**：
  - ✅ 已实现：RuleEngine连接失败 → 异常格口
  - ✅ 已实现：路径执行超时 → 异常格口
  - ✅ 已实现：格口未配置 → 异常格口
  - ✅ 已实现：传感器健康监控
  - ⚠️ 部分实现：自动重连（RuleEngine）
- **缺失功能**：
  - ❌ **自动故障恢复**：
    - 摆轮故障后无自动重试机制
    - 传感器故障后无自动恢复检测
    - 系统重启后无状态恢复
  - ❌ **配置备份恢复**：
    - LiteDB数据库无自动备份
    - 无配置版本历史
    - 配置损坏后难以恢复
  - ❌ **降级策略**：
    - 部分功能故障时无优雅降级
    - 无只读模式支持
  - ❌ **熔断保护**：
    - 虽有超时机制，但无熔断器模式
    - 连续失败时无主动停止
- **风险**：
  - 故障恢复依赖人工干预
  - 配置丢失风险
  - 级联故障风险
- **建议行动**：
  1. **实现自动重试机制**（预计：1-2天）
     - 摆轮控制失败：重试3次，指数退避
     - 传感器读取失败：重试并记录告警
  2. **配置自动备份**（预计：1天）
     - 每天自动备份LiteDB到备份目录
     - 保留最近7天备份
     - 提供配置恢复API
  3. **实现熔断器模式**（预计：1-2天）
     - 使用Polly库
     - RuleEngine连接：连续失败10次后熔断5分钟
     - 摆轮控制：连续失败5次后标记故障
  4. **状态持久化**（预计：2-3天）
     - 记录当前处理中的包裹状态
     - 系统重启后恢复未完成任务
     - 防止包裹丢失

#### 13. 文档组织待优化 ⚠️ **优先级：P4**
- **问题**：
  - 30+个独立MD文件，内容分散
  - 文档间关联不明确
  - 缺少统一的文档导航
  - 新人上手需要阅读大量文档
- **影响**：
  - 文档查找困难
  - 信息重复或不一致
  - 学习成本高
- **建议行动**：
  1. **文档重组**：
     - 合并相关文档（如IMPLEMENTATION_SUMMARY_*.md）
     - 建立清晰的文档层次结构
     - 添加文档索引页
  2. **补充缺失文档**：
     - 快速开始指南
     - 故障排查手册
     - 运维操作手册
     - 开发指南
  3. **生成在线文档**（可选）：
     - 使用Docusaurus或VuePress
     - 自动发布到GitHub Pages

#### 14. 其他改进建议 ⚠️ **优先级：P5**
- **多语言支持**：
  - 当前仅支持中文
  - 建议：添加英文文档和界面（国际化i18n）
- **移动端支持**：
  - 开发移动端监控App（可选）
  - 或确保Web界面响应式设计
- **API版本管理**：
  - 当前无版本控制
  - 建议：引入API版本（如/api/v1/、/api/v2/）
- **持续改进**：
  - 定期收集用户反馈
  - 建立功能需求优先级评估机制
  - 保持代码和文档同步更新

### 🆕 硬件相关风险跟踪

| 风险项 | 描述 | 影响 | 建议 | 状态 |
|-------|------|------|------|------|
| 硬件兼容性 | 不同型号PLC协议可能不同 | 驱动失效或功能异常 | 详细测试各型号，建立兼容性列表 | ⚠️ 需注意 |
| 驱动版本冲突 | 不同厂商DLL可能冲突 | 系统崩溃或行为异常 | 使用独立AppDomain或进程隔离 | ⚠️ 需注意 |
| 设备掉线 | 网络中断或设备断电 | 分拣中断，包裹堆积 | ✅ 已实现自动检测和告警 | ✅ 已解决 |
| 传感器故障 | 传感器硬件损坏或读取错误 | 无法检测包裹，分拣停滞 | ✅ 已实现健康监控和故障检测 | ✅ 已解决 |
| 指令延迟 | PLC响应慢或网络延迟高 | 分拣效率低或超时 | 优化通信协议，添加预读机制 | ⚠️ 需优化 |
| 传感器误触发 | 环境干扰或灵敏度过高 | 错误检测包裹 | ✅ 已实现去抖动机制 | ✅ 已解决 |
| 并发资源冲突 | 多包裹同时请求同一摆轮 | 分拣错误或效率降低 | ✅ 已实现资源锁和队列管理 | ✅ 已解决 |

## 技术栈

- **.NET 8.0**: 核心框架
- **ASP.NET Core Minimal API**: Web API框架
- **依赖注入（DI）**: 服务管理
- **LiteDB**: 配置数据存储
- **雷赛LTDMC**: 硬件控制器驱动

## 相关文档

- [系统配置管理指南](SYSTEM_CONFIG_GUIDE.md)
- [配置管理API文档](CONFIGURATION_API.md)
- [API使用教程](API_USAGE_GUIDE.md)
- [通信层集成文档](COMMUNICATION_INTEGRATION.md)
- [与规则引擎的关系文档](RELATIONSHIP_WITH_RULEENGINE.md)
- [硬件驱动文档](ZakYip.WheelDiverterSorter.Drivers/README.md)
- [测试文档](TESTING.md)

## 贡献指南

1. Fork本仓库
2. 创建特性分支 (`git checkout -b feature/AmazingFeature`)
3. 提交更改 (`git commit -m 'Add some AmazingFeature'`)
4. 推送到分支 (`git push origin feature/AmazingFeature`)
5. 创建Pull Request

---

**最后更新：2025-11-13**  
**文档版本：v2.0** - 完整的问题分析和优化路线图  
**下次审核：2025-12-13**（每月更新）
