# ZakYip.WheelDiverterSorter

直线摆轮分拣系统 - 基于方向控制的包裹自动分拣解决方案

## 📐 系统拓扑结构

本系统采用直线拓扑结构，包裹在传送带上单向流动，通过摆轮转向实现分拣：

```
      格口B     格口D     格口F
        ↑         ↑         ↑
入口 → 摆轮D1 → 摆轮D2 → 摆轮D3 → 末端(默认异常口)
  ↓     ↓         ↓         ↓
传感器  格口A      格口C     格口E
```

### 拓扑说明

- **入口传感器**：检测包裹到达，触发系统创建包裹记录
- **摆轮D1/D2/D3**：每个摆轮前有IO传感器，确认包裹到达并触发转向动作
- **格口A-F**：6个分拣格口，分别位于3个摆轮的左右两侧
- **末端异常口**：包裹直行通过所有摆轮后到达，用于收集异常包裹

### 转向方向定义

摆轮支持三种转向方向（**不使用具体角度**）：

- **直行（Straight）**：包裹继续前进到下一个摆轮
- **左转（Left）**：包裹分流到摆轮左侧格口（图中上方）
- **右转（Right）**：包裹分流到摆轮右侧格口（图中下方）

## ⚠️ 重要说明

本程序和 [ZakYip.Sorting.RuleEngine.Core](https://github.com/Hisoka6602/ZakYip.Sorting.RuleEngine.Core) 是**分开部署**的两个独立程序，互为上下游关系：

- **ZakYip.WheelDiverterSorter（本项目，下游）**：
  - 通过**IO传感器**感应物理包裹并创建包裹记录
  - 向RuleEngine请求格口号
  - 负责**实际执行分拣**动作（控制摆轮）

- **ZakYip.Sorting.RuleEngine.Core（上游）**：
  - 接收包裹ID请求
  - 与**DWS第三方API**通信获取包裹信息（条码、重量、尺寸等）
  - 通过规则引擎决策目标格口号
  - 返回格口号给WheelDiverterSorter

**通信方式：** 两个系统通过**TCP/SignalR/MQTT**等协议通信（多选一）
- ✅ **生产环境推荐**：TCP、SignalR或MQTT（高性能、长连接）
- ❌ **生产环境禁止**：HTTP（仅用于模拟测试，性能不足）

**⚠️ 异常处理策略：**
- 如果**连接不上RuleEngine**，包裹将**默认路由到异常格口**
- 系统会记录连接失败日志，但不会阻塞包裹流转
- 异常格口ID可通过系统配置修改（默认：`CHUTE_EXCEPTION`）

详细的系统关系和集成方案请参阅：[与规则引擎的关系文档](RELATIONSHIP_WITH_RULEENGINE.md)

---

## 项目简介

本项目是一个基于直线摆轮（Wheel Diverter）的包裹自动分拣系统。包裹通过传感器检测进入系统，在输送线上单向移动，经过配置的摆轮节点时，根据转向方向分流到目标格口。系统采用分层架构设计，支持路径规划、执行和可观测性。

### 核心特点

- ✅ **方向控制模式**：摆轮使用左/右/直行方向控制，不依赖具体角度
- ✅ **传感器驱动**：入口和每个摆轮前配置IO传感器，实时跟踪包裹位置
- ✅ **动态配置**：通过LiteDB存储配置，支持运行时热更新
- ✅ **多协议通信**：支持TCP/SignalR/MQTT/HTTP与上游规则引擎通信
- ✅ **推送模型**：格口分配由上游推送，支持超时保护

## 🔄 系统工作流程

### 完整流程（生产环境）

```
1. 包裹入口
   ↓
   入口传感器检测 → 创建包裹ID
   ↓
2. 请求格口分配
   ↓
   通过TCP/SignalR/MQTT向RuleEngine请求格口号
   ↓
   RuleEngine与DWS通信获取包裹信息
   ↓
   RuleEngine决策并返回目标格口ID
   ↓
3. 路径生成
   ↓
   根据目标格口ID生成摆轮转向路径
   例如：格口E需要 [D1:直行, D2:直行, D3:右转]
   ↓
4. 路径执行
   ↓
   包裹到达D1 → D1传感器触发 → 检查路径 → D1执行直行
   ↓
   包裹到达D2 → D2传感器触发 → 检查路径 → D2执行直行
   ↓
   包裹到达D3 → D3传感器触发 → 检查路径 → D3执行右转
   ↓
   包裹分流到格口E
   ↓
5. 完成分拣
```

### 传感器工作逻辑

1. **入口传感器**
   - 检测包裹物理到达
   - 生成唯一包裹ID（基于时间戳）
   - 触发格口分配请求

2. **摆轮前传感器（D1/D2/D3）**
   - 确认包裹到达当前摆轮位置
   - 更新包裹位置状态
   - 触发摆轮执行转向动作
   - 验证包裹是否在TTL时间内到达（超时检测）

3. **传感器特性**
   - 去抖动机制：防止传感器误触发
   - 健康监控：实时监测传感器状态
   - 故障检测：传感器异常时触发告警

### 路径规划逻辑

系统根据目标格口ID，从LiteDB配置中查找摆轮转向序列：

| 目标格口 | 摆轮路径 | 说明 |
|---------|---------|------|
| 格口A | D1:右转 | 直接在第一个摆轮右转 |
| 格口B | D1:左转 | 直接在第一个摆轮左转 |
| 格口C | D1:直行 → D2:右转 | 通过D1后在D2右转 |
| 格口D | D1:直行 → D2:左转 | 通过D1后在D2左转 |
| 格口E | D1:直行 → D2:直行 → D3:右转 | 通过D1、D2后在D3右转 |
| 格口F | D1:直行 → D2:直行 → D3:左转 | 通过D1、D2后在D3左转 |
| 异常口 | D1:直行 → D2:直行 → D3:直行 | 所有摆轮直行，到达末端 |

### 异常处理机制

1. **格口未配置**：目标格口在配置中不存在 → 自动路由到异常口
2. **路径执行超时**：包裹在TTL时间内未到达下一个摆轮 → 路由到异常口
3. **摆轮控制失败**：硬件故障或通信失败 → 路由到异常口
4. **RuleEngine连接失败**：无法获取格口分配 → 默认路由到异常口
5. **传感器故障**：传感器异常时触发告警，包裹继续流转

### 时间控制与超时检测

每个格口配置包含：

- **皮带速度（BeltSpeedMeterPerSecond）**：米/秒
- **皮带长度（BeltLengthMeter）**：从上一检测点到当前格口的距离
- **容差时间（ToleranceTimeMs）**：允许的时间误差范围

系统根据这些参数计算包裹预期到达时间：
```
预期到达时间 = 皮带长度 / 皮带速度 ± 容差时间
```

如果包裹超过 `预期时间 + 容差时间` 仍未到达，则判定为丢包或超时。

---

## 项目结构

- **ZakYip.WheelDiverterSorter.Core**: 核心业务逻辑，包含路径生成器、方向枚举、配置管理
- **ZakYip.WheelDiverterSorter.Execution**: 执行层，包含路径执行器和模拟实现
- **ZakYip.WheelDiverterSorter.Drivers**: 硬件驱动层，包含PLC控制器驱动和IO端口抽象
- **ZakYip.WheelDiverterSorter.Ingress**: 入口管理，传感器驱动、包裹检测、健康监控
- **ZakYip.WheelDiverterSorter.Communication**: 通信层，TCP/SignalR/MQTT/HTTP客户端
- **ZakYip.WheelDiverterSorter.Host**: Web API主机，提供调试接口和配置管理API  
- **ZakYip.WheelDiverterSorter.Observability**: 可观测性支持

---

## 📋 最近更新记录

### 🆕 更新 5: 直线拓扑结构与方向控制重构 (2025-11-13)
- **方向控制替代角度控制**：摆轮从角度控制（0/30/45/90度）改为方向控制（直行/左转/右转）
- **明确拓扑结构**：定义清晰的直线拓扑，3个摆轮，6个格口（每个摆轮左右各一个格口）
- **传感器工作逻辑**：详细说明入口传感器和摆轮前传感器的工作流程
- **路径规划优化**：基于新拓扑结构更新默认格口配置（CHUTE_A到CHUTE_F）
- **文档全面更新**：README.md增加完整的工作流程、时间控制、异常处理说明
- **硬件解耦**：方向到角度转换由硬件驱动层处理，系统逻辑更清晰

### 更新 4: 配置管理增强与热更新支持 (2025-11-13)
- **枚举类型安全**：新增`SensorVendorType`和`DriverVendorType`枚举，替代魔法字符串，提升类型安全
- **LiteDB配置存储**：驱动器、传感器、通信配置全部迁移到LiteDB，支持运行时热更新
- **格口配置增强**：添加皮带速度、皮带长度、容差时间，支持精确的超时检测和丢包判断
- **传感器IO配置**：每个格口配置独立的触发传感器IO，实现实时位置跟踪和动态时间计算
- **新增API端点**：
  - `GET/PUT/RESET /api/config/driver` - 驱动器配置管理
  - `GET/PUT/RESET /api/config/sensor` - 传感器配置管理
  - `GET/PUT/RESET /api/config/communication` - 通信配置管理
- **配置验证**：所有配置增加严格验证逻辑，确保数据一致性和正确性

### 更新 1: 推送模型与类型安全改进 (2025-11-12)
- **推送模型实现**：从请求/响应模型改为推送/回调模型，格口号由上游推送而非主动请求
- **超时保护**：支持格口分配等待超时（默认10秒），超时后自动分配到异常格口
- **类型安全增强**：使用常量类和枚举替代魔法字符串和数字，提高代码可维护性
- **客户端适配**：SignalR/MQTT原生支持推送，TCP/HTTP通过适配器模式支持

详细说明：[推送模型实现总结](IMPLEMENTATION_SUMMARY_PUSH_MODEL.md)

### 更新 2: 并发控制机制 (2025-11-12)
- **摆轮资源锁**：基于读写锁的摆轮资源管理，防止并发冲突
- **包裹队列管理**：优先级队列支持，批量处理相同目标格口的包裹
- **并发限流保护**：可配置的最大并发数，防止系统过载
- **装饰器模式集成**：非侵入式添加并发控制，无需修改现有代码

详细说明：[并发控制机制文档](CONCURRENCY_CONTROL.md)

### 更新 3: 性能优化与基准测试 (2025-11-12)
- **BenchmarkDotNet集成**：完整的性能基准测试套件，测试路径生成和执行性能
- **性能指标收集**：集成.NET标准Metrics API，支持Prometheus/OpenTelemetry导出
- **缓存机制**：路径生成结果缓存，减少重复计算，提升响应速度
- **对象池优化**：使用ArrayPool减少内存分配，降低GC压力

详细说明：[性能优化总结](PERFORMANCE_SUMMARY.md)

---

## 项目当前完成度

**整体完成度：约 92%**

### ✅ 已完成的核心功能

| 模块 | 完成度 | 说明 |
|-----|--------|------|
| 核心路径生成 | 100% | 基于格口到摆轮映射的路径生成，支持LiteDB动态配置和热更新 |
| 配置管理系统 | 100% | 🆕 全面的LiteDB存储，所有热更新配置（驱动器、传感器、通信、路由）均支持API管理和验证 |
| 格口配置系统 | 100% | 🆕 支持皮带速度/长度、容差时间、传感器IO配置，实现精确超时检测 |
| 执行器层 | 100% | 模拟执行器和硬件执行器完整实现，支持配置切换 |
| 通信层 | 100% | TCP/SignalR/MQTT/HTTP客户端全部实现，支持推送模型，与RuleEngine完整集成 |
| 并发控制 | 100% | 摆轮资源锁、包裹队列管理、并发限流保护全部实现 |
| 性能优化 | 95% | 基准测试、性能指标收集、缓存机制、对象池优化已完成 |
| 类型安全 | 100% | 🆕 枚举类型替代字符串，VendorType、CommunicationMode等全面使用枚举 |
| 调试接口 | 100% | HTTP API端点用于测试，集成Swagger文档 |

### 🚧 部分完成的功能

| 模块 | 完成度 | 已完成 | 待完成 |
|-----|--------|--------|--------|
| 硬件驱动层 | 80% | 雷赛控制器驱动、IO端口抽象 | 西门子/三菱/欧姆龙等PLC厂商支持 |
| 传感器系统 | 85% | 雷赛传感器驱动、健康监控、故障检测 | 其他厂商传感器、扫码触发集成 |
| 可观测性 | 50% | 基础日志记录、性能指标收集、传感器健康监控 | Prometheus/Grafana仪表板、OpenTelemetry追踪、告警系统 |
| 测试覆盖 | 15% | 基准性能测试 | 单元测试、集成测试、端到端测试 |

### ❌ 未完成的功能（功能缺失清单）

#### 1. 硬件驱动层缺失
- **多厂商PLC支持**：仅支持雷赛控制器，缺少西门子（Siemens S7系列）、三菱（Mitsubishi FX/Q系列）、欧姆龙（Omron CP/CJ/NJ系列）等主流PLC驱动
- **驱动插件化架构**：缺少动态加载驱动的插件系统，无法运行时切换不同厂商驱动
- **硬件兼容性测试**：缺少不同型号PLC的兼容性测试和验证
- **驱动DLL管理**：原生DLL需手动部署，缺少自动化管理机制

#### 2. 高级路径规划缺失
- **拓扑图建模**：不支持基于拓扑图的路径搜索，当前仅支持硬编码映射
- **动态路径优化**：无法根据设备状态、负载情况动态选择最优路径
- **多路径选择**：不支持备份路径和容错路径
- **路径成本计算**：缺少基于距离、时间、摆轮切换次数的成本优化算法
- **智能调度**：无法考虑设备维护、故障节点自动绕行

#### 3. 生产环境功能缺失
- **Web管理界面**：无可视化管理界面，仅有API接口
- **用户权限管理**：缺少用户认证和授权机制

#### 4. 系统设计说明（不需要实现的功能）
以下功能根据系统架构设计，**不需要在本系统中实现**：
- **扫码触发集成**：❌ 不需要 - 本系统使用IO传感器检测包裹物理到达，不依赖条码扫描
- **供包台关联**：❌ 不需要 - 本系统仅负责分拣执行，与上游RuleEngine通信获取格口号即可
- **包裹历史存储**：❌ 不需要 - 上游RuleEngine已存储包裹数据和历史记录，本系统仅执行分拣
- **数据报表功能**：❌ 不需要 - 报表和统计功能由上游系统负责，本系统专注于分拣执行

**重要架构原则**：
- ✅ 本系统是**纯执行层**，负责根据格口号控制摆轮完成物理分拣
- ✅ **包裹创建**：由IO传感器感应物理包裹到达后创建
- ✅ **格口决策**：由上游RuleEngine负责，本系统通过TCP/SignalR/MQTT通信获取
- ✅ **数据存储**：上游RuleEngine负责持久化，本系统不存储历史数据
- ✅ **异常处理**：如果连接不上RuleEngine，包裹默认路由到异常格口

#### 5. 测试体系缺失
- **单元测试**：核心业务逻辑缺少单元测试覆盖（覆盖率接近0%）
- **集成测试**：缺少模块间集成测试，如路径生成与执行的集成测试
- **端到端测试**：缺少完整流程的E2E测试（从包裹检测到分拣完成）
- **硬件驱动Mock测试**：缺少硬件驱动的模拟测试框架
- **压力测试验证**：未在高并发场景（1000+包裹/分钟）下进行充分测试
- **自动化测试CI/CD**：缺少持续集成的自动化测试流程

#### 6. 可观测性功能缺失
- **Grafana仪表板**：缺少可视化监控面板（分拣成功率、吞吐量、设备状态等）
- **Prometheus集成**：虽有性能指标收集，但未完整集成Prometheus导出器
- **OpenTelemetry追踪**：缺少分布式链路追踪，无法追踪单个包裹的完整处理流程
- **实时告警系统**：缺少钉钉/企业微信/邮件/短信告警集成
- **日志聚合**：缺少ELK/Loki等日志聚合和搜索系统
- **性能分析工具**：缺少APM（Application Performance Monitoring）工具集成

#### 7. 安全性功能缺失
- **API认证授权**：调试接口缺少认证机制，存在安全风险
- **数据加密**：敏感配置数据未加密存储
- **操作审计日志**：缺少配置变更、操作记录的审计功能
- **输入验证增强**：部分API端点的输入验证不够严格

#### 8. 容错和恢复机制缺失
- **故障自动恢复**：设备故障后缺少自动恢复和重试机制
- **数据备份恢复**：缺少配置和数据的备份恢复功能
- **降级策略**：系统部分功能故障时缺少优雅降级机制
- **熔断保护**：缺少对外部依赖（如RuleEngine）的熔断保护（注：已实现连接失败时路由到异常格口）

#### 9. 其他功能缺失
- **多语言支持**：界面和文档仅支持中文，缺少国际化
- **移动端支持**：缺少移动端管理应用
- **API版本管理**：API缺少版本控制机制
- **文档完整性**：部分模块缺少详细的技术文档和操作手册

## 🎯 未来优化方向

### 优先级1：完善测试体系（高优先级）⏰ 预计3-4周

**目标**：建立完整的测试体系，保证代码质量和系统稳定性

**任务清单**：
- [ ] 核心逻辑单元测试（目标覆盖率>80%）
- [ ] API端点集成测试
- [ ] 硬件驱动Mock设备测试
- [ ] 端到端集成测试（包括与RuleEngine的集成）
- [ ] 压力测试和性能调优（目标：500-1000包裹/分钟）
- [ ] CI/CD自动化测试流程

### 优先级2：多厂商硬件支持（高优先级）⏰ 预计2-3周

**目标**：扩展支持更多PLC厂商，提升系统兼容性

**任务清单**：
- [ ] 实现西门子（Siemens）S7系列PLC驱动（S7-200/300/1200/1500）
- [ ] 实现三菱（Mitsubishi）FX/Q系列PLC驱动
- [ ] 实现欧姆龙（Omron）CP/CJ/NJ系列PLC驱动
- [ ] 实现驱动插件化架构，支持动态加载
- [ ] 建立硬件兼容性测试矩阵

### 优先级3：可观测性增强（中优先级）⏰ 预计3-4周

**目标**：建立完整的监控、告警和追踪体系

**任务清单**：
- [ ] 集成Prometheus指标导出器
- [ ] Grafana监控仪表板（分拣成功率、延迟、设备状态、队列长度等）
- [ ] OpenTelemetry链路追踪集成
- [ ] 实时告警系统（钉钉/邮件/短信集成）
- [ ] 设备健康检查和预警机制完善
- [ ] 性能指标可视化和分析

### 优先级4：高级路径算法（中优先级）⏰ 预计4-5周

**目标**：实现智能路径规划和优化

**任务清单**：
- [ ] 基于拓扑图的动态路径搜索算法
- [ ] 多路径选择和备份路径支持
- [ ] 考虑设备状态的智能路径规划
- [ ] 动态负载均衡算法
- [ ] 路径成本优化（最短路径、最少摆轮切换等）

### 优先级5：生产环境功能完善（持续开发）⏰ 持续开发

**目标**：补齐生产环境必需的功能

**任务清单**：
- [ ] Web管理界面（实时监控、配置管理）
- [ ] 异常处理和人工干预流程增强
- [ ] 异常处理和人工干预流程增强

**总体时间线**：完成核心优化预计需要 **10-14周**

---

## 项目结构

- **ZakYip.WheelDiverterSorter.Core**: 核心业务逻辑，包含路径生成器接口和实现
- **ZakYip.WheelDiverterSorter.Execution**: 执行层，包含路径执行器接口和模拟实现
- **ZakYip.WheelDiverterSorter.Drivers**: 🆕 硬件驱动层，包含PLC控制器驱动和IO端口抽象
- **ZakYip.WheelDiverterSorter.Host**: Web API 主机，提供调试接口和配置管理API
- **ZakYip.WheelDiverterSorter.Ingress**: 入口管理（✅ **已完成**：真实传感器和健康监控已实现）
- **ZakYip.WheelDiverterSorter.Observability**: 可观测性支持（待实现）
- **ZakYip.WheelDiverterSorter.Communication**: 通信层（✅ **已完成** 🆕：TCP/SignalR/MQTT/HTTP客户端全部实现）

## 项目运行流程

### 系统启动流程

1. **启动Web API主机**
   ```bash
   cd ZakYip.WheelDiverterSorter.Host
   dotnet run
   ```
   - 默认监听端口：5000（HTTP）
   - 自动注册依赖服务（路径生成器、执行器）

2. **系统初始化**
   - 加载摆轮拓扑配置（当前使用硬编码映射）
   - 初始化路径生成器和执行器
   - 启动Web API监听

### 包裹分拣流程

#### 完整工作流程（生产环境）

```
IO传感器感应 → 创建包裹 → 请求格口号(TCP/SignalR/MQTT) → RuleEngine决策 
→ 接收格口号 → 生成摆轮路径 → 执行路径 → 到达目标格口
```

#### 当前流程（测试环境）

```
手动触发HTTP API → 生成摆轮路径 → 执行路径 → 到达目标格口
```

#### 详细步骤说明

1. **包裹入口**
   - **生产模式（待实现）**：
     - IO传感器感应包裹到达
     - 自动创建包裹记录并生成包裹ID
     - 通过TCP/SignalR/MQTT向RuleEngine.Core请求格口号
     - RuleEngine与DWS第三方API通信获取包裹信息
     - RuleEngine返回目标格口ID
   - **调试模式（当前实现）**：
     - 通过HTTP API手动触发 `POST /api/debug/sort`
     - 直接提供包裹ID和目标格口ID
     - ⚠️ 此模式仅用于测试，生产环境禁用HTTP

2. **路径生成阶段** (`ISwitchingPathGenerator`)
   - 接收包裹ID和目标格口ID
   - 查询格口到摆轮的映射关系
   - 生成有序的摆轮路径段列表（`SwitchingPath`）
   - 每段包含：摆轮ID、目标角度、TTL（超时时间）
   - 如果格口未配置，返回null，包裹将走异常口

3. **路径执行阶段** (`ISwitchingPathExecutor`)
   - 按顺序执行每个路径段
   - 模拟执行器：模拟设备响应延迟
   - 真实执行器（待实现）：与PLC/设备通信，控制摆轮角度
   - 监控每段的TTL，超时则标记失败

4. **结果反馈**
   - 执行成功：返回目标格口ID
   - 执行失败：返回异常格口ID和失败原因
   - 记录执行日志供后续分析

## 工作原理

### 核心概念

#### 1. 摆轮（Wheel Diverter）

摆轮是安装在直线输送线上的分拣设备，通过旋转不同角度将包裹分流到不同方向：

- **0度**：包裹直行通过
- **30度/45度**：小角度分流（常用于相邻格口）
- **90度**：大角度分流（常用于垂直分拣）

#### 2. 直线拓扑结构

```
入口 → 摆轮D1 → 摆轮D2 → 摆轮D3 → 末端
        ↓         ↓         ↓
     格口B      格口A     格口C
```

包裹在输送线上单向移动，经过配置的摆轮节点时，根据路径指令分流到目标格口。

#### 3. 路径规划

**当前实现（硬编码映射）**：
```csharp
// 格口A：需要经过摆轮D1（30度）和摆轮D2（45度）
"CHUTE_A" -> [D1:30°, D2:45°]

// 格口B：需要经过摆轮D1（0度直行）
"CHUTE_B" -> [D1:0°]

// 格口C：需要经过摆轮D1（90度）和摆轮D3（30度）
"CHUTE_C" -> [D1:90°, D3:30°]
```

**未来实现（基于拓扑的动态路径搜索）**：
- 从拓扑模型 (`SorterTopology`) 自动计算最优路径
- 支持多条路径选择和负载均衡
- 考虑设备状态和故障节点

#### 4. 路径段与TTL

每个路径段包含：
- **摆轮ID**：指定哪个摆轮执行动作
- **目标角度**：摆轮应旋转到的角度
- **TTL（Time To Live）**：该段的最大执行时间（默认5000ms）

如果段执行超过TTL，视为失败，包裹将被引导到异常格口。

#### 5. 异常处理机制

- **路径生成失败**：目标格口未配置 → 返回null → 包裹走异常口
- **路径执行失败**：段超时或设备故障 → 返回失败结果 → 包裹走异常口
- **异常格口**：默认为 `CHUTE_EXCEPTION`，用于收集所有异常包裹

## 调试接口

### 概述

Host 层提供了一个用于调试直线摆轮方案的最小接口。

**注意**：这是调试入口，生产环境应使用IO传感器触发包裹检测。

### API 端点

**POST** `/api/debug/sort`

#### 请求参数

```json
{
  "parcelId": "包裹ID",
  "targetChuteId": "目标格口ID"
}
```

#### 响应示例

成功案例（格口E）：
```json
{
  "parcelId": "PKG001",
  "targetChuteId": "CHUTE_E",
  "isSuccess": true,
  "actualChuteId": "CHUTE_E",
  "message": "分拣成功：包裹 PKG001 已成功分拣到格口 CHUTE_E",
  "failureReason": null,
  "pathSegmentCount": 3
}
```

失败案例（未知格口）：
```json
{
  "parcelId": "PKG004",
  "targetChuteId": "CHUTE_UNKNOWN",
  "isSuccess": false,
  "actualChuteId": "未知",
  "message": "路径生成失败：目标格口无法映射到任何摆轮组合",
  "failureReason": "目标格口未配置或不存在",
  "pathSegmentCount": 0
}
```

### 使用示例

测试格口A（D1右转）：
```bash
curl -X POST http://localhost:5000/api/debug/sort \
  -H "Content-Type: application/json" \
  -d '{"parcelId": "PKG001", "targetChuteId": "CHUTE_A"}'
```

测试格口E（D1直行→D2直行→D3右转）：
```bash
curl -X POST http://localhost:5000/api/debug/sort \
  -H "Content-Type: application/json" \
  -d '{"parcelId": "PKG002", "targetChuteId": "CHUTE_E"}'
```

### 工作流程

1. 接收包裹ID和目标格口ID
2. 调用路径生成器（`ISwitchingPathGenerator`）生成 `SwitchingPath`
3. 调用执行器（`ISwitchingPathExecutor`）执行路径
4. 返回执行结果和实际落格ID

### 预配置的格口

当前默认配置包含以下6个格口（基于直线拓扑结构）：

| 格口ID | 位置 | 路径配置 | 说明 |
|--------|------|---------|------|
| **CHUTE_A** | D1右侧 | D1:右转 | 最近的格口，包裹在第一个摆轮即分流 |
| **CHUTE_B** | D1左侧 | D1:左转 | 第一个摆轮左侧格口 |
| **CHUTE_C** | D2右侧 | D1:直行 → D2:右转 | 需通过D1才能到达 |
| **CHUTE_D** | D2左侧 | D1:直行 → D2:左转 | 第二个摆轮左侧格口 |
| **CHUTE_E** | D3右侧 | D1:直行 → D2:直行 → D3:右转 | 最远的右侧格口 |
| **CHUTE_F** | D3左侧 | D1:直行 → D2:直行 → D3:左转 | 最远的左侧格口 |

**拓扑示意图**：
```
      格口B     格口D     格口F
        ↑         ↑         ↑
入口 → 摆轮D1 → 摆轮D2 → 摆轮D3 → 末端(异常口)
        ↓         ↓         ↓
     格口A      格口C     格口E
```

**注意**: 这些配置存储在 LiteDB 数据库中，可以通过配置管理 API 动态修改。

### 路径配置示例

#### 示例 1: 格口A（简单路径）
```json
{
  "chuteId": "CHUTE_A",
  "chuteName": "格口A（D1右侧）",
  "diverterConfigurations": [
    {
      "diverterId": "D1",
      "targetDirection": "Right",
      "sequenceNumber": 1
    }
  ],
  "beltSpeedMeterPerSecond": 1.5,
  "beltLengthMeter": 5.0,
  "toleranceTimeMs": 2000,
  "isEnabled": true
}
```

#### 示例 2: 格口E（复杂路径）
```json
{
  "chuteId": "CHUTE_E",
  "chuteName": "格口E（D3右侧）",
  "diverterConfigurations": [
    {
      "diverterId": "D1",
      "targetDirection": "Straight",
      "sequenceNumber": 1
    },
    {
      "diverterId": "D2",
      "targetDirection": "Straight",
      "sequenceNumber": 2
    },
    {
      "diverterId": "D3",
      "targetDirection": "Right",
      "sequenceNumber": 3
    }
  ],
  "beltSpeedMeterPerSecond": 1.5,
  "beltLengthMeter": 15.0,
  "toleranceTimeMs": 2000,
  "isEnabled": true
}
```

## 配置管理 API

系统提供了完整的 RESTful API 用于动态管理所有配置，支持热更新（无需重启）。所有频繁变动的配置已从 appsettings.json 迁移到 LiteDB 数据库。

### 主要功能

- ✅ **动态配置管理**: 通过 API 添加、修改、删除各类配置
- ✅ **热更新支持**: 配置更改立即生效，无需重启应用
- ✅ **数据持久化**: 使用 LiteDB 存储配置数据
- ✅ **配置验证**: 自动验证配置的正确性和完整性
- ✅ **类型安全**: 使用枚举类型，避免魔法字符串和数字

### API 端点总览

#### 1️⃣ 格口路由配置

| 方法 | 端点 | 说明 |
|------|------|------|
| GET | `/api/config/routes` | 获取所有路由配置 |
| GET | `/api/config/routes/{chuteId}` | 获取指定格口配置 |
| POST | `/api/config/routes` | 创建新的路由配置 |
| PUT | `/api/config/routes/{chuteId}` | 更新路由配置（热更新） |
| DELETE | `/api/config/routes/{chuteId}` | 删除路由配置 |

#### 2️⃣ 驱动器配置 🆕

| 方法 | 端点 | 说明 |
|------|------|------|
| GET | `/api/config/driver` | 获取驱动器配置 |
| PUT | `/api/config/driver` | 更新驱动器配置（热更新） |
| POST | `/api/config/driver/reset` | 重置为默认配置 |

#### 3️⃣ 传感器配置 🆕

| 方法 | 端点 | 说明 |
|------|------|------|
| GET | `/api/config/sensor` | 获取传感器配置 |
| PUT | `/api/config/sensor` | 更新传感器配置（热更新） |
| POST | `/api/config/sensor/reset` | 重置为默认配置 |

#### 4️⃣ 通信配置 🆕

| 方法 | 端点 | 说明 |
|------|------|------|
| GET | `/api/config/communication` | 获取通信配置 |
| PUT | `/api/config/communication` | 更新通信配置（热更新） |
| POST | `/api/config/communication/reset` | 重置为默认配置 |

#### 5️⃣ 系统配置

| 方法 | 端点 | 说明 |
|------|------|------|
| GET | `/api/config/system` | 获取系统配置 |
| PUT | `/api/config/system` | 更新系统配置（热更新） |
| POST | `/api/config/system/reset` | 重置为默认配置 |

### 配置示例

#### 示例 1: 创建格口配置（基于方向控制）

```bash
curl -X POST http://localhost:5000/api/config/routes \
  -H "Content-Type: application/json" \
  -d '{
    "chuteId": "CHUTE_E",
    "chuteName": "格口E（D3右侧）",
    "diverterConfigurations": [
      {"diverterId": "D1", "targetDirection": "Straight", "sequenceNumber": 1},
      {"diverterId": "D2", "targetDirection": "Straight", "sequenceNumber": 2},
      {"diverterId": "D3", "targetDirection": "Right", "sequenceNumber": 3}
    ],
    "beltSpeedMeterPerSecond": 1.5,
    "beltLengthMeter": 15.0,
    "toleranceTimeMs": 2000,
    "sensorConfig": {
      "sensorId": "SENSOR_CHUTE_E_01",
      "sensorType": "Photoelectric",
      "inputBit": 8,
      "isEnabled": true,
      "debounceTimeMs": 100
    },
    "isEnabled": true
  }'
```

**说明**：
- `targetDirection` 可选值：`"Straight"`, `"Left"`, `"Right"`
- 格口E需要包裹通过D1和D2后，在D3右转到达
- 传感器配置用于检测包裹到达D3位置

#### 示例 2: 更新驱动器配置

```bash
curl -X PUT http://localhost:5000/api/config/driver \
  -H "Content-Type: application/json" \
  -d '{
    "useHardwareDriver": true,
    "vendorType": 1,
    "leadshine": {
      "cardNo": 0,
      "diverters": [
        {"diverterId": "D1", "outputStartBit": 0, "feedbackInputBit": 10},
        {"diverterId": "D2", "outputStartBit": 2, "feedbackInputBit": 11}
      ]
    }
  }'
```

#### 示例 3: 更新通信配置

```bash
curl -X PUT http://localhost:5000/api/config/communication \
  -H "Content-Type: application/json" \
  -d '{
    "mode": 1,
    "tcpServer": "192.168.1.100:8000",
    "timeoutMs": 5000,
    "retryCount": 3,
    "enableAutoReconnect": true
  }'
```

**说明**：
- `mode`: 0=Http, 1=Tcp, 2=SignalR, 3=Mqtt
- `vendorType`: 0=Mock, 1=Leadshine, 2=Siemens, 3=Mitsubishi, 4=Omron
- 所有配置更新后立即生效，无需重启服务

详细的 API 文档请参阅：[配置管理 API 文档](CONFIGURATION_API.md)

## 运行项目

```bash
cd ZakYip.WheelDiverterSorter.Host
dotnet run
```

默认监听端口：5000（HTTP）

## ⚠️ 当前风险与缺陷

### ✅ 已解决的问题 (2025-11-13更新)

#### 1. 配置热更新问题 - ✅ 已解决
- **原问题**：驱动器、传感器、通信等配置写死在appsettings.json中，修改需要重启服务
- **解决方案**：全部迁移到LiteDB数据库，提供API端点进行热更新
- **影响**：✅ 现在可以在运行时动态修改配置，无需重启，大幅提升运维效率

#### 2. 类型安全问题 - ✅ 已解决
- **原问题**：VendorType使用字符串类型，容易拼写错误，缺少编译时检查
- **解决方案**：引入`SensorVendorType`和`DriverVendorType`枚举类型
- **影响**：✅ 编译时类型检查，避免运行时错误，代码更安全

#### 3. 超时检测缺失 - ✅ 已解决
- **原问题**：格口配置缺少容差时间，无法精确判断包裹超时或丢失
- **解决方案**：为每个格口添加皮带速度、皮带长度、容差时间配置
- **影响**：✅ 系统可以精确计算预期到达时间，准确检测超时和丢包

#### 4. 传感器IO配置缺失 - ✅ 已解决
- **原问题**：格口前传感器IO未配置，无法实时跟踪包裹位置
- **解决方案**：为每个格口添加独立的传感器IO配置（ChuteSensorConfig）
- **影响**：✅ 可以实时追踪包裹位置，动态计算到达下一格口的时间

### 🔴 高风险项（需尽快解决）

#### 1. 测试覆盖率严重不足
- **问题**：项目中几乎没有单元测试或集成测试（仅有性能基准测试）
- **风险**：代码重构或新增功能时易引入bug，质量无法保证
- **影响**：系统稳定性无保障，回归测试成本高，难以保证生产环境质量
- **建议**：立即建立测试体系，核心逻辑覆盖率目标>80%

#### 2. 多厂商硬件支持不足
- **问题**：仅支持雷赛（Leadshine）控制器，其他主流PLC厂商未支持
- **风险**：限制系统在不同硬件环境下的部署灵活性
- **影响**：无法在使用西门子、三菱、欧姆龙等PLC的现场部署
- **建议**：实现西门子/三菱/欧姆龙PLC驱动，建立驱动插件化架构

#### 3. 系统架构已确认
- **说明**：以下功能根据架构设计**不需要实现**
- **扫码触发**：❌ 不需要 - 使用IO传感器，不依赖条码
- **供包台接口**：❌ 不需要 - 与上游RuleEngine通信即可
- **包裹历史**：❌ 不需要 - 上游RuleEngine负责存储
- **数据报表**：❌ 不需要 - 报表由上游系统提供
- **影响**：✅ 系统定位明确，专注于分拣执行层
- **建议**：保持当前架构，专注核心功能

### 🟡 中风险项（影响运维和优化）

#### 4. 可观测性仍需增强
- **问题**：虽有性能指标收集和传感器监控，但缺少可视化仪表板和完整告警系统
- **风险**：生产环境问题难以快速发现和处理
- **影响**：运维困难，故障响应慢，MTTR（平均修复时间）高
- **建议**：集成Grafana仪表板、完善告警系统（钉钉/邮件/短信）

#### 5. 路径算法较简单
- **问题**：当前使用直接映射，不考虑设备状态和负载，无备份路径
- **风险**：无法处理设备故障、维护场景，缺少容错能力
- **影响**：设备故障时分拣中断，无法自动切换备用路径
- **建议**：实现基于拓扑图的路径搜索、动态路径重规划、多路径支持

#### 6. 性能优化未充分验证
- **问题**：虽有缓存和对象池优化，但缺少实际高负载场景验证
- **风险**：不确定系统在高并发场景（1000+包裹/分钟）下的表现
- **影响**：可能在生产环境出现性能瓶颈
- **建议**：进行压力测试和负载测试，验证目标吞吐量

#### 7. TTL计算优化 - ⚠️ 部分改善
- **当前状态**：格口配置已支持皮带速度、长度和容差时间，可以精确计算预期到达时间
- **待改进**：路径段TTL仍使用固定值（5000ms），未与格口配置集成
- **影响**：格口级别的超时检测已完善，但摆轮段级别的TTL仍需优化
- **建议**：将格口配置的时间计算逻辑应用到路径段TTL，实现端到端的动态时间管理

### 🟢 低风险项（改进项）

#### 8. 硬件DLL管理
- **问题**：雷赛LTDMC.dll等原生DLL需要手动部署
- **风险**：部署复杂度增加，容易遗漏或版本不匹配
- **影响**：部署失败率高，难以自动化
- **建议**：使用NuGet打包、DLL版本检查、Docker镜像预装

#### 9. Web管理界面缺失
#### 9. Web管理界面缺失
- **问题**：仅有API接口，缺少友好的Web管理界面
- **风险**：操作不便，学习成本高
- **影响**：运维人员使用体验差，培训成本高
- **建议**：开发Web管理界面，提供实时监控、配置管理

### 🆕 硬件相关风险跟踪

| 风险项 | 描述 | 影响 | 建议 | 状态 |
|-------|------|------|------|------|
| 硬件兼容性 | 不同型号PLC协议可能不同 | 驱动失效或功能异常 | 详细测试各型号，建立兼容性列表 | ⚠️ 需注意 |
| 驱动版本冲突 | 不同厂商DLL可能冲突 | 系统崩溃或行为异常 | 使用独立AppDomain或进程隔离 | ⚠️ 需注意 |
| 设备掉线 | 网络中断或设备断电 | 分拣中断，包裹堆积 | ✅ 已实现自动检测和告警 | ✅ 已解决 |
| 传感器故障 | 传感器硬件损坏或读取错误 | 无法检测包裹，分拣停滞 | ✅ 已实现健康监控和故障检测 | ✅ 已解决 |
| 指令延迟 | PLC响应慢或网络延迟高 | 分拣效率低或超时 | 优化通信协议，添加预读机制 | ⚠️ 需优化 |
| 传感器误触发 | 环境干扰或灵敏度过高 | 错误检测包裹 | ✅ 已实现去抖动机制 | ✅ 已解决 |
| 并发资源冲突 | 多包裹同时请求同一摆轮 | 分拣错误或效率降低 | ✅ 已实现资源锁和队列管理 | ✅ 已解决 |

## 技术栈

- **.NET 8.0**: 核心框架
- **ASP.NET Core Minimal API**: Web API框架
- **依赖注入（DI）**: 服务管理
- **LiteDB**: 配置数据存储
- **雷赛LTDMC**: 硬件控制器驱动

## 相关文档

- [系统配置管理指南](SYSTEM_CONFIG_GUIDE.md)
- [配置管理API文档](CONFIGURATION_API.md)
- [API使用教程](API_USAGE_GUIDE.md)
- [通信层集成文档](COMMUNICATION_INTEGRATION.md)
- [与规则引擎的关系文档](RELATIONSHIP_WITH_RULEENGINE.md)
- [硬件驱动文档](ZakYip.WheelDiverterSorter.Drivers/README.md)
- [测试文档](TESTING.md)

## 贡献指南

1. Fork本仓库
2. 创建特性分支 (`git checkout -b feature/AmazingFeature`)
3. 提交更改 (`git commit -m 'Add some AmazingFeature'`)
4. 推送到分支 (`git push origin feature/AmazingFeature`)
5. 创建Pull Request

---

**最后更新：2025-11-13**
