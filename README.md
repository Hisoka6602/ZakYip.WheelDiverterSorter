# ZakYip.WheelDiverterSorter

直线摆轮分拣系统

## ⚠️ 重要说明

本程序和 [ZakYip.Sorting.RuleEngine.Core](https://github.com/Hisoka6602/ZakYip.Sorting.RuleEngine.Core) 是**分开部署**的两个独立程序，互为上下游关系：

- **ZakYip.WheelDiverterSorter（本项目，下游）**：
  - 通过**IO传感器**感应物理包裹并创建包裹记录
  - 向RuleEngine请求格口号
  - 负责**实际执行分拣**动作（控制摆轮）

- **ZakYip.Sorting.RuleEngine.Core（上游）**：
  - 接收包裹ID请求
  - 与**DWS第三方API**通信获取包裹信息（条码、重量、尺寸等）
  - 通过规则引擎决策目标格口号
  - 返回格口号给WheelDiverterSorter

**通信方式：** 两个系统通过**TCP/SignalR/MQTT**等协议通信（多选一）
- ✅ **生产环境推荐**：TCP、SignalR或MQTT（高性能、长连接）
- ❌ **生产环境禁止**：HTTP（仅用于模拟测试，性能不足）

详细的系统关系和集成方案请参阅：[与规则引擎的关系文档](RELATIONSHIP_WITH_RULEENGINE.md)

---

## 项目简介

本项目是一个基于直线摆轮（Wheel Diverter）的包裹自动分拣系统。通过在直线输送线上配置多个摆轮节点，实现包裹到不同格口的智能分拣。系统采用分层架构设计，支持路径规划、执行和可观测性。

---

## 📋 最近更新记录

### 更新 1: 系统配置管理增强 (2025-11-12)
- **LiteDB配置存储**：系统级配置存储在LiteDB数据库中，支持环境迁移
- **热重载支持**：配置更新后立即生效，无需重启服务
- **完整的REST API**：提供配置管理API（获取、更新、重置配置）
- **配置验证**：自动验证所有参数的有效性（端口范围、超时时间等）
- **版本控制**：每次更新自动递增版本号，便于追踪变更

详细说明：[系统配置管理指南](SYSTEM_CONFIG_GUIDE.md)

### 更新 2: API文档系统集成 (2025-11-12)
- **Swagger/OpenAPI文档**：集成Swashbuckle.AspNetCore，提供交互式API文档
- **中文界面支持**：API文档使用中文标题和描述
- **Postman集合**：提供预配置的Postman collection，可直接导入测试

访问地址：启动服务后访问 `http://localhost:5000/swagger`

### 更新 3: 传感器健康监控系统 (2025-11-12)
- **健康监控服务**：`ISensorHealthMonitor` 接口和 `SensorHealthMonitor` 实现
- **故障检测机制**：自动检测连续错误、长时间无响应等异常情况
- **故障分类**：通信超时、读取错误、设备离线等类型分类
- **故障告警**：通过事件通知传感器故障和恢复
- **健康统计**：记录触发次数、错误次数、运行时长等指标

---

## 项目当前完成度

### ✅ 核心功能（已完成）

| 模块 | 完成度 | 说明 |
|-----|--------|------|
| 核心路径生成 | 100% | 基于格口到摆轮映射的路径生成，支持LiteDB动态配置和热更新 |
| 配置管理系统 | 100% | RESTful API管理配置，支持热重载和验证 |
| 执行器层 | 100% | 模拟执行器和硬件执行器完整实现，支持配置切换 |
| 通信层 | 100% | TCP/SignalR/MQTT/HTTP客户端全部实现，与RuleEngine完整集成 |
| 调试接口 | 100% | HTTP API端点用于测试，集成Swagger文档 |

### 🚧 部分完成功能

| 模块 | 完成度 | 已完成 | 待完成 |
|-----|--------|--------|--------|
| 硬件驱动层 | 80% | 雷赛控制器驱动、IO端口抽象 | 西门子/三菱/欧姆龙等PLC厂商支持 |
| 传感器系统 | 85% | 雷赛传感器驱动、健康监控、故障检测 | 扫码触发、供包台集成 |
| 可观测性 | 30% | 基础日志记录 | Prometheus指标、OpenTelemetry追踪、告警系统 |

### ❌ 未实现功能

- **多厂商硬件支持**：仅支持雷赛控制器，缺少西门子、三菱、欧姆龙等PLC驱动
- **高级路径算法**：不支持基于拓扑图的动态路径优化和负载均衡
- **生产环境功能**：缺少扫码触发、供包台接口、包裹跟踪、异常告警、监控仪表板
- **测试覆盖**：无单元测试、集成测试和性能测试
- **并发控制**：缺少摆轮资源锁和包裹队列管理机制

**整体完成度：约 85%**

## 🎯 未来优化方向

### 优先级1：多厂商硬件支持（高优先级）⏰ 预计2-3周

**目标**：扩展支持更多PLC厂商，提升系统兼容性

**任务清单**：
- [ ] 实现西门子（Siemens）S7系列PLC驱动（S7-200/300/1200/1500）
- [ ] 实现三菱（Mitsubishi）FX/Q系列PLC驱动
- [ ] 实现欧姆龙（Omron）CP/CJ/NJ系列PLC驱动
- [ ] 实现驱动插件化架构，支持动态加载

### 优先级2：并发控制机制（高优先级）⏰ 预计2-3周

**目标**：解决高并发场景下的资源冲突问题

**任务清单**：
- [ ] 实现摆轮资源锁机制（读写锁或信号量）
- [ ] 添加包裹队列管理（优先级队列）
- [ ] 优化路径调度算法，批量处理相同目标的包裹
- [ ] 实现动态负载均衡

### 优先级3：测试与质量保障（高优先级）⏰ 预计3-4周

**目标**：建立完整的测试体系，保证代码质量

**任务清单**：
- [ ] 核心逻辑单元测试（目标覆盖率>80%）
- [ ] API端点集成测试
- [ ] 硬件驱动Mock设备测试
- [ ] 性能和压力测试（目标：500-1000包裹/分钟）
- [ ] CI/CD自动化测试流程

### 优先级4：可观测性增强（中优先级）⏰ 预计3-4周

**目标**：建立完整的监控、告警和追踪体系

**任务清单**：
- [ ] 集成Prometheus指标收集
- [ ] Grafana监控仪表板（分拣成功率、延迟、设备状态等）
- [ ] OpenTelemetry链路追踪
- [ ] 实时告警系统（钉钉/邮件/短信）
- [ ] 设备健康检查和预警

### 优先级5：生产环境功能（中优先级）⏰ 持续开发

**目标**：完善生产环境必需的功能

**任务清单**：
- [ ] 包裹跟踪和历史记录
- [ ] Web管理界面
- [ ] 扫码触发集成
- [ ] 供包台接口
- [ ] 动态路径优化算法
- [ ] 数据报表和分析

**总体时间线**：完成核心优化预计需要 **8-12周**

---

## 项目结构

- **ZakYip.WheelDiverterSorter.Core**: 核心业务逻辑，包含路径生成器接口和实现
- **ZakYip.WheelDiverterSorter.Execution**: 执行层，包含路径执行器接口和模拟实现
- **ZakYip.WheelDiverterSorter.Drivers**: 🆕 硬件驱动层，包含PLC控制器驱动和IO端口抽象
- **ZakYip.WheelDiverterSorter.Host**: Web API 主机，提供调试接口和配置管理API
- **ZakYip.WheelDiverterSorter.Ingress**: 入口管理（✅ **已完成**：真实传感器和健康监控已实现）
- **ZakYip.WheelDiverterSorter.Observability**: 可观测性支持（待实现）
- **ZakYip.WheelDiverterSorter.Communication**: 通信层（✅ **已完成** 🆕：TCP/SignalR/MQTT/HTTP客户端全部实现）

## 项目运行流程

### 系统启动流程

1. **启动Web API主机**
   ```bash
   cd ZakYip.WheelDiverterSorter.Host
   dotnet run
   ```
   - 默认监听端口：5000（HTTP）
   - 自动注册依赖服务（路径生成器、执行器）

2. **系统初始化**
   - 加载摆轮拓扑配置（当前使用硬编码映射）
   - 初始化路径生成器和执行器
   - 启动Web API监听

### 包裹分拣流程

#### 完整工作流程（生产环境）

```
IO传感器感应 → 创建包裹 → 请求格口号(TCP/SignalR/MQTT) → RuleEngine决策 
→ 接收格口号 → 生成摆轮路径 → 执行路径 → 到达目标格口
```

#### 当前流程（测试环境）

```
手动触发HTTP API → 生成摆轮路径 → 执行路径 → 到达目标格口
```

#### 详细步骤说明

1. **包裹入口**
   - **生产模式（待实现）**：
     - IO传感器感应包裹到达
     - 自动创建包裹记录并生成包裹ID
     - 通过TCP/SignalR/MQTT向RuleEngine.Core请求格口号
     - RuleEngine与DWS第三方API通信获取包裹信息
     - RuleEngine返回目标格口ID
   - **调试模式（当前实现）**：
     - 通过HTTP API手动触发 `POST /api/debug/sort`
     - 直接提供包裹ID和目标格口ID
     - ⚠️ 此模式仅用于测试，生产环境禁用HTTP

2. **路径生成阶段** (`ISwitchingPathGenerator`)
   - 接收包裹ID和目标格口ID
   - 查询格口到摆轮的映射关系
   - 生成有序的摆轮路径段列表（`SwitchingPath`）
   - 每段包含：摆轮ID、目标角度、TTL（超时时间）
   - 如果格口未配置，返回null，包裹将走异常口

3. **路径执行阶段** (`ISwitchingPathExecutor`)
   - 按顺序执行每个路径段
   - 模拟执行器：模拟设备响应延迟
   - 真实执行器（待实现）：与PLC/设备通信，控制摆轮角度
   - 监控每段的TTL，超时则标记失败

4. **结果反馈**
   - 执行成功：返回目标格口ID
   - 执行失败：返回异常格口ID和失败原因
   - 记录执行日志供后续分析

## 工作原理

### 核心概念

#### 1. 摆轮（Wheel Diverter）

摆轮是安装在直线输送线上的分拣设备，通过旋转不同角度将包裹分流到不同方向：

- **0度**：包裹直行通过
- **30度/45度**：小角度分流（常用于相邻格口）
- **90度**：大角度分流（常用于垂直分拣）

#### 2. 直线拓扑结构

```
入口 → 摆轮D1 → 摆轮D2 → 摆轮D3 → 末端
        ↓         ↓         ↓
     格口B      格口A     格口C
```

包裹在输送线上单向移动，经过配置的摆轮节点时，根据路径指令分流到目标格口。

#### 3. 路径规划

**当前实现（硬编码映射）**：
```csharp
// 格口A：需要经过摆轮D1（30度）和摆轮D2（45度）
"CHUTE_A" -> [D1:30°, D2:45°]

// 格口B：需要经过摆轮D1（0度直行）
"CHUTE_B" -> [D1:0°]

// 格口C：需要经过摆轮D1（90度）和摆轮D3（30度）
"CHUTE_C" -> [D1:90°, D3:30°]
```

**未来实现（基于拓扑的动态路径搜索）**：
- 从拓扑模型 (`SorterTopology`) 自动计算最优路径
- 支持多条路径选择和负载均衡
- 考虑设备状态和故障节点

#### 4. 路径段与TTL

每个路径段包含：
- **摆轮ID**：指定哪个摆轮执行动作
- **目标角度**：摆轮应旋转到的角度
- **TTL（Time To Live）**：该段的最大执行时间（默认5000ms）

如果段执行超过TTL，视为失败，包裹将被引导到异常格口。

#### 5. 异常处理机制

- **路径生成失败**：目标格口未配置 → 返回null → 包裹走异常口
- **路径执行失败**：段超时或设备故障 → 返回失败结果 → 包裹走异常口
- **异常格口**：默认为 `CHUTE_EXCEPTION`，用于收集所有异常包裹

## 调试接口

### 概述

Host 层提供了一个用于调试直线摆轮方案的最小接口。

**注意**：这是调试入口，正式环境可改成由扫码触发或供包台触发。

### API 端点

**POST** `/api/debug/sort`

#### 请求参数

```json
{
  "parcelId": "包裹ID",
  "targetChuteId": "目标格口ID"
}
```

#### 响应示例

成功案例：
```json
{
  "parcelId": "PKG001",
  "targetChuteId": "CHUTE_A",
  "isSuccess": true,
  "actualChuteId": "CHUTE_A",
  "message": "分拣成功：包裹 PKG001 已成功分拣到格口 CHUTE_A",
  "failureReason": null,
  "pathSegmentCount": 2
}
```

失败案例（未知格口）：
```json
{
  "parcelId": "PKG004",
  "targetChuteId": "CHUTE_UNKNOWN",
  "isSuccess": false,
  "actualChuteId": "未知",
  "message": "路径生成失败：目标格口无法映射到任何摆轮组合",
  "failureReason": "目标格口未配置或不存在",
  "pathSegmentCount": 0
}
```

### 使用示例

```bash
curl -X POST http://localhost:5000/api/debug/sort \
  -H "Content-Type: application/json" \
  -d '{"parcelId": "PKG001", "targetChuteId": "CHUTE_A"}'
```

### 工作流程

1. 接收包裹ID和目标格口ID
2. 调用路径生成器（`ISwitchingPathGenerator`）生成 `SwitchingPath`
3. 调用执行器（`ISwitchingPathExecutor`）执行路径
4. 返回执行结果和实际落格ID

### 预配置的格口

当前默认配置包含以下格口映射：

- **CHUTE_A**: 需要经过摆轮D1（30度）和摆轮D2（45度）
- **CHUTE_B**: 需要经过摆轮D1（0度直行）
- **CHUTE_C**: 需要经过摆轮D1（90度）和摆轮D3（30度）

**注意**: 这些配置存储在 LiteDB 数据库中，可以通过配置管理 API 动态修改。

## 配置管理 API

系统提供了完整的 RESTful API 用于动态管理格口到摆轮的路由配置，支持热更新（无需重启）。

### 主要功能

- ✅ **动态配置管理**: 通过 API 添加、修改、删除格口配置
- ✅ **热更新支持**: 配置更改立即生效，无需重启应用
- ✅ **数据持久化**: 使用 LiteDB 存储配置数据
- ✅ **配置验证**: 自动验证配置的正确性和完整性

### API 端点

| 方法 | 端点 | 说明 |
|------|------|------|
| GET | `/api/config/routes` | 获取所有路由配置 |
| GET | `/api/config/routes/{chuteId}` | 获取指定格口配置 |
| POST | `/api/config/routes` | 创建新的路由配置 |
| PUT | `/api/config/routes/{chuteId}` | 更新路由配置（热更新） |
| DELETE | `/api/config/routes/{chuteId}` | 删除路由配置 |

### 快速示例

```bash
# 创建新格口配置
curl -X POST http://localhost:5000/api/config/routes \
  -H "Content-Type: application/json" \
  -d '{
    "chuteId": "CHUTE_D",
    "diverterConfigurations": [
      {"diverterId": "D2", "targetAngle": 45, "sequenceNumber": 1},
      {"diverterId": "D3", "targetAngle": 90, "sequenceNumber": 2}
    ],
    "isEnabled": true
  }'

# 立即使用新配置（无需重启）
curl -X POST http://localhost:5000/api/debug/sort \
  -H "Content-Type: application/json" \
  -d '{"parcelId": "PKG001", "targetChuteId": "CHUTE_D"}'
```

详细的 API 文档请参阅：[配置管理 API 文档](CONFIGURATION_API.md)

## 运行项目

```bash
cd ZakYip.WheelDiverterSorter.Host
dotnet run
```

默认监听端口：5000（HTTP）

## ⚠️ 当前风险与缺陷

### 🔴 高风险项（需尽快解决）

#### 1. 多厂商硬件支持不足
- **问题**：仅支持雷赛（Leadshine）控制器，其他主流PLC厂商未支持
- **风险**：限制系统在不同硬件环境下的部署灵活性
- **影响**：无法在使用西门子、三菱、欧姆龙等PLC的现场部署
- **建议**：实现西门子/三菱/欧姆龙PLC驱动，建立驱动插件化架构

#### 2. 并发控制缺失
- **问题**：多个包裹同时请求同一摆轮时，可能产生冲突
- **风险**：摆轮角度切换频繁，降低分拣效率或导致分拣错误
- **影响**：高并发场景下系统不可用或分拣错误率高
- **建议**：实现摆轮资源锁机制、包裹队列管理、动态负载均衡

#### 3. 测试覆盖为零
- **问题**：项目中没有任何单元测试或集成测试
- **风险**：代码重构或新增功能时易引入bug，质量无法保证
- **影响**：系统稳定性无保障，回归测试成本高
- **建议**：建立完整测试体系，核心逻辑覆盖率目标>80%

### 🟡 中风险项（影响运维和优化）

#### 4. 可观测性不足
- **问题**：无指标收集、链路追踪、告警机制（传感器层已有基础监控）
- **风险**：生产环境问题难以排查和监控
- **影响**：运维困难，故障响应慢，MTTR（平均修复时间）高
- **建议**：集成Prometheus/Grafana、OpenTelemetry、告警系统

#### 5. 硬件驱动错误处理不完善
- **问题**：执行器层和控制器层的错误分类和恢复策略不够详细（传感器层已完善）
- **风险**：无法准确判断故障原因，影响问题定位
- **影响**：设备故障时排查困难，恢复时间长
- **建议**：细化错误分类、实现自动恢复策略、设备健康检查

#### 6. 路径算法简单
- **问题**：当前使用直接映射，不考虑设备状态和负载
- **风险**：无法处理设备故障、维护场景
- **影响**：缺少容错能力和优化空间
- **建议**：实现基于拓扑图的路径搜索、动态路径重规划、负载均衡

#### 7. 静态TTL设置
- **问题**：所有路径段使用固定5000ms的TTL
- **风险**：无法适应不同距离的摆轮节点或不同速度的输送线
- **影响**：可能导致不必要的超时或资源浪费
- **建议**：根据摆轮位置和输送速度动态计算TTL

### 🟢 低风险项（改进项）

#### 8. 硬件DLL管理
- **问题**：雷赛LTDMC.dll等原生DLL需要手动部署
- **风险**：部署复杂度增加，容易遗漏或版本不匹配
- **影响**：部署失败率高，难以自动化
- **建议**：使用NuGet打包、DLL版本检查、Docker镜像预装

#### 9. 日志注入防护不完整
- **问题**：虽然实现了基本的日志清理，但可能不够全面
- **风险**：潜在的日志注入攻击风险
- **影响**：安全性问题
- **建议**：使用结构化日志（Serilog）、输入验证和白名单、日志脱敏

#### 10. 生产功能缺失
- **问题**：缺少扫码触发、供包台接口、包裹跟踪、Web管理界面等
- **风险**：生产环境使用不便
- **影响**：运营效率低，用户体验差
- **建议**：逐步补齐生产环境必需功能

### 🆕 硬件相关新增风险

| 风险项 | 描述 | 影响 | 建议 | 状态 |
|-------|------|------|------|------|
| 硬件兼容性 | 不同型号PLC协议可能不同 | 驱动失效或功能异常 | 详细测试各型号，建立兼容性列表 | ⚠️ 需注意 |
| 驱动版本冲突 | 不同厂商DLL可能冲突 | 系统崩溃或行为异常 | 使用独立AppDomain或进程隔离 | ⚠️ 需注意 |
| 设备掉线 | 网络中断或设备断电 | 分拣中断，包裹堆积 | ✅ 已实现自动检测和告警 | ✅ 已解决 |
| 传感器故障 | 传感器硬件损坏或读取错误 | 无法检测包裹，分拣停滞 | ✅ 已实现健康监控和故障检测 | ✅ 已解决 |
| 指令延迟 | PLC响应慢或网络延迟高 | 分拣效率低或超时 | 优化通信协议，添加预读机制 | ⚠️ 需优化 |
| 传感器误触发 | 环境干扰或灵敏度过高 | 错误检测包裹 | ✅ 已实现去抖动机制 | ✅ 已解决 |

## 技术栈

- **.NET 8.0**: 核心框架
- **ASP.NET Core Minimal API**: Web API框架
- **依赖注入（DI）**: 服务管理
- **LiteDB**: 配置数据存储
- **雷赛LTDMC**: 硬件控制器驱动

## 相关文档

- [系统配置管理指南](SYSTEM_CONFIG_GUIDE.md)
- [配置管理API文档](CONFIGURATION_API.md)
- [API使用教程](API_USAGE_GUIDE.md)
- [通信层集成文档](COMMUNICATION_INTEGRATION.md)
- [与规则引擎的关系文档](RELATIONSHIP_WITH_RULEENGINE.md)
- [硬件驱动文档](ZakYip.WheelDiverterSorter.Drivers/README.md)
- [测试文档](TESTING.md)

## 贡献指南

1. Fork本仓库
2. 创建特性分支 (`git checkout -b feature/AmazingFeature`)
3. 提交更改 (`git commit -m 'Add some AmazingFeature'`)
4. 推送到分支 (`git push origin feature/AmazingFeature`)
5. 创建Pull Request

---

**最后更新：2025-11-12**
