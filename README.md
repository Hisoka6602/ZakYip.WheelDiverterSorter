# ZakYip.WheelDiverterSorter

直线摆轮分拣系统

## ⚠️ 重要说明

本程序和 [ZakYip.Sorting.RuleEngine.Core](https://github.com/Hisoka6602/ZakYip.Sorting.RuleEngine.Core) 是**分开部署**的两个独立程序，互为上下游关系：

- **ZakYip.WheelDiverterSorter（本项目，下游）**：
  - 通过**IO传感器**感应物理包裹并创建包裹记录
  - 向RuleEngine请求格口号
  - 负责**实际执行分拣**动作（控制摆轮）

- **ZakYip.Sorting.RuleEngine.Core（上游）**：
  - 接收包裹ID请求
  - 与**DWS第三方API**通信获取包裹信息（条码、重量、尺寸等）
  - 通过规则引擎决策目标格口号
  - 返回格口号给WheelDiverterSorter

**通信方式：** 两个系统通过**TCP/SignalR/MQTT**等协议通信（多选一）
- ✅ **生产环境推荐**：TCP、SignalR或MQTT（高性能、长连接）
- ❌ **生产环境禁止**：HTTP（仅用于模拟测试，性能不足）

**⚠️ 异常处理策略：**
- 如果**连接不上RuleEngine**，包裹将**默认路由到异常格口**
- 系统会记录连接失败日志，但不会阻塞包裹流转
- 异常格口ID可通过系统配置修改（默认：`CHUTE_EXCEPTION`）

详细的系统关系和集成方案请参阅：[与规则引擎的关系文档](RELATIONSHIP_WITH_RULEENGINE.md)

---

## 项目简介

本项目是一个基于直线摆轮（Wheel Diverter）的包裹自动分拣系统。通过在直线输送线上配置多个摆轮节点，实现包裹到不同格口的智能分拣。系统采用分层架构设计，支持路径规划、执行和可观测性。

---

## 📋 最近更新记录

### 更新 1: 推送模型与类型安全改进 (2025-11-12)
- **推送模型实现**：从请求/响应模型改为推送/回调模型，格口号由上游推送而非主动请求
- **超时保护**：支持格口分配等待超时（默认10秒），超时后自动分配到异常格口
- **类型安全增强**：使用常量类和枚举替代魔法字符串和数字，提高代码可维护性
- **客户端适配**：SignalR/MQTT原生支持推送，TCP/HTTP通过适配器模式支持

详细说明：[推送模型实现总结](IMPLEMENTATION_SUMMARY_PUSH_MODEL.md)

### 更新 2: 并发控制机制 (2025-11-12)
- **摆轮资源锁**：基于读写锁的摆轮资源管理，防止并发冲突
- **包裹队列管理**：优先级队列支持，批量处理相同目标格口的包裹
- **并发限流保护**：可配置的最大并发数，防止系统过载
- **装饰器模式集成**：非侵入式添加并发控制，无需修改现有代码

详细说明：[并发控制机制文档](CONCURRENCY_CONTROL.md)

### 更新 3: 性能优化与基准测试 (2025-11-12)
- **BenchmarkDotNet集成**：完整的性能基准测试套件，测试路径生成和执行性能
- **性能指标收集**：集成.NET标准Metrics API，支持Prometheus/OpenTelemetry导出
- **缓存机制**：路径生成结果缓存，减少重复计算，提升响应速度
- **对象池优化**：使用ArrayPool减少内存分配，降低GC压力

详细说明：[性能优化总结](PERFORMANCE_SUMMARY.md)

---

## 项目当前完成度

**整体完成度：约 88%**

### ✅ 已完成的核心功能

| 模块 | 完成度 | 说明 |
|-----|--------|------|
| 核心路径生成 | 100% | 基于格口到摆轮映射的路径生成，支持LiteDB动态配置和热更新 |
| 配置管理系统 | 100% | RESTful API管理配置，支持热重载和验证 |
| 执行器层 | 100% | 模拟执行器和硬件执行器完整实现，支持配置切换 |
| 通信层 | 100% | TCP/SignalR/MQTT/HTTP客户端全部实现，支持推送模型，与RuleEngine完整集成 |
| 并发控制 | 100% | 摆轮资源锁、包裹队列管理、并发限流保护全部实现 |
| 性能优化 | 95% | 基准测试、性能指标收集、缓存机制、对象池优化已完成 |
| 调试接口 | 100% | HTTP API端点用于测试，集成Swagger文档 |

### 🚧 部分完成的功能

| 模块 | 完成度 | 已完成 | 待完成 |
|-----|--------|--------|--------|
| 硬件驱动层 | 80% | 雷赛控制器驱动、IO端口抽象 | 西门子/三菱/欧姆龙等PLC厂商支持 |
| 传感器系统 | 85% | 雷赛传感器驱动、健康监控、故障检测 | 其他厂商传感器、扫码触发集成 |
| 可观测性 | 50% | 基础日志记录、性能指标收集、传感器健康监控 | Prometheus/Grafana仪表板、OpenTelemetry追踪、告警系统 |
| 测试覆盖 | 15% | 基准性能测试 | 单元测试、集成测试、端到端测试 |

### ❌ 未完成的功能（功能缺失清单）

#### 1. 硬件驱动层缺失
- **多厂商PLC支持**：仅支持雷赛控制器，缺少西门子（Siemens S7系列）、三菱（Mitsubishi FX/Q系列）、欧姆龙（Omron CP/CJ/NJ系列）等主流PLC驱动
- **驱动插件化架构**：缺少动态加载驱动的插件系统，无法运行时切换不同厂商驱动
- **硬件兼容性测试**：缺少不同型号PLC的兼容性测试和验证
- **驱动DLL管理**：原生DLL需手动部署，缺少自动化管理机制

#### 2. 高级路径规划缺失
- **拓扑图建模**：不支持基于拓扑图的路径搜索，当前仅支持硬编码映射
- **动态路径优化**：无法根据设备状态、负载情况动态选择最优路径
- **多路径选择**：不支持备份路径和容错路径
- **路径成本计算**：缺少基于距离、时间、摆轮切换次数的成本优化算法
- **智能调度**：无法考虑设备维护、故障节点自动绕行

#### 3. 生产环境功能缺失
- **Web管理界面**：无可视化管理界面，仅有API接口
- **用户权限管理**：缺少用户认证和授权机制

#### 4. 系统设计说明（不需要实现的功能）
以下功能根据系统架构设计，**不需要在本系统中实现**：
- **扫码触发集成**：❌ 不需要 - 本系统使用IO传感器检测包裹物理到达，不依赖条码扫描
- **供包台关联**：❌ 不需要 - 本系统仅负责分拣执行，与上游RuleEngine通信获取格口号即可
- **包裹历史存储**：❌ 不需要 - 上游RuleEngine已存储包裹数据和历史记录，本系统仅执行分拣
- **数据报表功能**：❌ 不需要 - 报表和统计功能由上游系统负责，本系统专注于分拣执行

**重要架构原则**：
- ✅ 本系统是**纯执行层**，负责根据格口号控制摆轮完成物理分拣
- ✅ **包裹创建**：由IO传感器感应物理包裹到达后创建
- ✅ **格口决策**：由上游RuleEngine负责，本系统通过TCP/SignalR/MQTT通信获取
- ✅ **数据存储**：上游RuleEngine负责持久化，本系统不存储历史数据
- ✅ **异常处理**：如果连接不上RuleEngine，包裹默认路由到异常格口

#### 5. 测试体系缺失
- **单元测试**：核心业务逻辑缺少单元测试覆盖（覆盖率接近0%）
- **集成测试**：缺少模块间集成测试，如路径生成与执行的集成测试
- **端到端测试**：缺少完整流程的E2E测试（从包裹检测到分拣完成）
- **硬件驱动Mock测试**：缺少硬件驱动的模拟测试框架
- **压力测试验证**：未在高并发场景（1000+包裹/分钟）下进行充分测试
- **自动化测试CI/CD**：缺少持续集成的自动化测试流程

#### 6. 可观测性功能缺失
- **Grafana仪表板**：缺少可视化监控面板（分拣成功率、吞吐量、设备状态等）
- **Prometheus集成**：虽有性能指标收集，但未完整集成Prometheus导出器
- **OpenTelemetry追踪**：缺少分布式链路追踪，无法追踪单个包裹的完整处理流程
- **实时告警系统**：缺少钉钉/企业微信/邮件/短信告警集成
- **日志聚合**：缺少ELK/Loki等日志聚合和搜索系统
- **性能分析工具**：缺少APM（Application Performance Monitoring）工具集成

#### 7. 安全性功能缺失
- **API认证授权**：调试接口缺少认证机制，存在安全风险
- **数据加密**：敏感配置数据未加密存储
- **操作审计日志**：缺少配置变更、操作记录的审计功能
- **输入验证增强**：部分API端点的输入验证不够严格

#### 8. 容错和恢复机制缺失
- **故障自动恢复**：设备故障后缺少自动恢复和重试机制
- **数据备份恢复**：缺少配置和数据的备份恢复功能
- **降级策略**：系统部分功能故障时缺少优雅降级机制
- **熔断保护**：缺少对外部依赖（如RuleEngine）的熔断保护（注：已实现连接失败时路由到异常格口）

#### 9. 其他功能缺失
- **多语言支持**：界面和文档仅支持中文，缺少国际化
- **移动端支持**：缺少移动端管理应用
- **API版本管理**：API缺少版本控制机制
- **文档完整性**：部分模块缺少详细的技术文档和操作手册

## 🎯 未来优化方向

### 优先级1：完善测试体系（高优先级）⏰ 预计3-4周

**目标**：建立完整的测试体系，保证代码质量和系统稳定性

**任务清单**：
- [ ] 核心逻辑单元测试（目标覆盖率>80%）
- [ ] API端点集成测试
- [ ] 硬件驱动Mock设备测试
- [ ] 端到端集成测试（包括与RuleEngine的集成）
- [ ] 压力测试和性能调优（目标：500-1000包裹/分钟）
- [ ] CI/CD自动化测试流程

### 优先级2：多厂商硬件支持（高优先级）⏰ 预计2-3周

**目标**：扩展支持更多PLC厂商，提升系统兼容性

**任务清单**：
- [ ] 实现西门子（Siemens）S7系列PLC驱动（S7-200/300/1200/1500）
- [ ] 实现三菱（Mitsubishi）FX/Q系列PLC驱动
- [ ] 实现欧姆龙（Omron）CP/CJ/NJ系列PLC驱动
- [ ] 实现驱动插件化架构，支持动态加载
- [ ] 建立硬件兼容性测试矩阵

### 优先级3：可观测性增强（中优先级）⏰ 预计3-4周

**目标**：建立完整的监控、告警和追踪体系

**任务清单**：
- [ ] 集成Prometheus指标导出器
- [ ] Grafana监控仪表板（分拣成功率、延迟、设备状态、队列长度等）
- [ ] OpenTelemetry链路追踪集成
- [ ] 实时告警系统（钉钉/邮件/短信集成）
- [ ] 设备健康检查和预警机制完善
- [ ] 性能指标可视化和分析

### 优先级4：高级路径算法（中优先级）⏰ 预计4-5周

**目标**：实现智能路径规划和优化

**任务清单**：
- [ ] 基于拓扑图的动态路径搜索算法
- [ ] 多路径选择和备份路径支持
- [ ] 考虑设备状态的智能路径规划
- [ ] 动态负载均衡算法
- [ ] 路径成本优化（最短路径、最少摆轮切换等）

### 优先级5：生产环境功能完善（持续开发）⏰ 持续开发

**目标**：补齐生产环境必需的功能

**任务清单**：
- [ ] Web管理界面（实时监控、配置管理）
- [ ] 异常处理和人工干预流程增强
- [ ] 异常处理和人工干预流程增强

**总体时间线**：完成核心优化预计需要 **10-14周**

---

## 项目结构

- **ZakYip.WheelDiverterSorter.Core**: 核心业务逻辑，包含路径生成器接口和实现
- **ZakYip.WheelDiverterSorter.Execution**: 执行层，包含路径执行器接口和模拟实现
- **ZakYip.WheelDiverterSorter.Drivers**: 🆕 硬件驱动层，包含PLC控制器驱动和IO端口抽象
- **ZakYip.WheelDiverterSorter.Host**: Web API 主机，提供调试接口和配置管理API
- **ZakYip.WheelDiverterSorter.Ingress**: 入口管理（✅ **已完成**：真实传感器和健康监控已实现）
- **ZakYip.WheelDiverterSorter.Observability**: 可观测性支持（待实现）
- **ZakYip.WheelDiverterSorter.Communication**: 通信层（✅ **已完成** 🆕：TCP/SignalR/MQTT/HTTP客户端全部实现）

## 项目运行流程

### 系统启动流程

1. **启动Web API主机**
   ```bash
   cd ZakYip.WheelDiverterSorter.Host
   dotnet run
   ```
   - 默认监听端口：5000（HTTP）
   - 自动注册依赖服务（路径生成器、执行器）

2. **系统初始化**
   - 加载摆轮拓扑配置（当前使用硬编码映射）
   - 初始化路径生成器和执行器
   - 启动Web API监听

### 包裹分拣流程

#### 完整工作流程（生产环境）

```
IO传感器感应 → 创建包裹 → 请求格口号(TCP/SignalR/MQTT) → RuleEngine决策 
→ 接收格口号 → 生成摆轮路径 → 执行路径 → 到达目标格口
```

#### 当前流程（测试环境）

```
手动触发HTTP API → 生成摆轮路径 → 执行路径 → 到达目标格口
```

#### 详细步骤说明

1. **包裹入口**
   - **生产模式（待实现）**：
     - IO传感器感应包裹到达
     - 自动创建包裹记录并生成包裹ID
     - 通过TCP/SignalR/MQTT向RuleEngine.Core请求格口号
     - RuleEngine与DWS第三方API通信获取包裹信息
     - RuleEngine返回目标格口ID
   - **调试模式（当前实现）**：
     - 通过HTTP API手动触发 `POST /api/debug/sort`
     - 直接提供包裹ID和目标格口ID
     - ⚠️ 此模式仅用于测试，生产环境禁用HTTP

2. **路径生成阶段** (`ISwitchingPathGenerator`)
   - 接收包裹ID和目标格口ID
   - 查询格口到摆轮的映射关系
   - 生成有序的摆轮路径段列表（`SwitchingPath`）
   - 每段包含：摆轮ID、目标角度、TTL（超时时间）
   - 如果格口未配置，返回null，包裹将走异常口

3. **路径执行阶段** (`ISwitchingPathExecutor`)
   - 按顺序执行每个路径段
   - 模拟执行器：模拟设备响应延迟
   - 真实执行器（待实现）：与PLC/设备通信，控制摆轮角度
   - 监控每段的TTL，超时则标记失败

4. **结果反馈**
   - 执行成功：返回目标格口ID
   - 执行失败：返回异常格口ID和失败原因
   - 记录执行日志供后续分析

## 工作原理

### 核心概念

#### 1. 摆轮（Wheel Diverter）

摆轮是安装在直线输送线上的分拣设备，通过旋转不同角度将包裹分流到不同方向：

- **0度**：包裹直行通过
- **30度/45度**：小角度分流（常用于相邻格口）
- **90度**：大角度分流（常用于垂直分拣）

#### 2. 直线拓扑结构

```
入口 → 摆轮D1 → 摆轮D2 → 摆轮D3 → 末端
        ↓         ↓         ↓
     格口B      格口A     格口C
```

包裹在输送线上单向移动，经过配置的摆轮节点时，根据路径指令分流到目标格口。

#### 3. 路径规划

**当前实现（硬编码映射）**：
```csharp
// 格口A：需要经过摆轮D1（30度）和摆轮D2（45度）
"CHUTE_A" -> [D1:30°, D2:45°]

// 格口B：需要经过摆轮D1（0度直行）
"CHUTE_B" -> [D1:0°]

// 格口C：需要经过摆轮D1（90度）和摆轮D3（30度）
"CHUTE_C" -> [D1:90°, D3:30°]
```

**未来实现（基于拓扑的动态路径搜索）**：
- 从拓扑模型 (`SorterTopology`) 自动计算最优路径
- 支持多条路径选择和负载均衡
- 考虑设备状态和故障节点

#### 4. 路径段与TTL

每个路径段包含：
- **摆轮ID**：指定哪个摆轮执行动作
- **目标角度**：摆轮应旋转到的角度
- **TTL（Time To Live）**：该段的最大执行时间（默认5000ms）

如果段执行超过TTL，视为失败，包裹将被引导到异常格口。

#### 5. 异常处理机制

- **路径生成失败**：目标格口未配置 → 返回null → 包裹走异常口
- **路径执行失败**：段超时或设备故障 → 返回失败结果 → 包裹走异常口
- **异常格口**：默认为 `CHUTE_EXCEPTION`，用于收集所有异常包裹

## 调试接口

### 概述

Host 层提供了一个用于调试直线摆轮方案的最小接口。

**注意**：这是调试入口，正式环境可改成由扫码触发或供包台触发。

### API 端点

**POST** `/api/debug/sort`

#### 请求参数

```json
{
  "parcelId": "包裹ID",
  "targetChuteId": "目标格口ID"
}
```

#### 响应示例

成功案例：
```json
{
  "parcelId": "PKG001",
  "targetChuteId": "CHUTE_A",
  "isSuccess": true,
  "actualChuteId": "CHUTE_A",
  "message": "分拣成功：包裹 PKG001 已成功分拣到格口 CHUTE_A",
  "failureReason": null,
  "pathSegmentCount": 2
}
```

失败案例（未知格口）：
```json
{
  "parcelId": "PKG004",
  "targetChuteId": "CHUTE_UNKNOWN",
  "isSuccess": false,
  "actualChuteId": "未知",
  "message": "路径生成失败：目标格口无法映射到任何摆轮组合",
  "failureReason": "目标格口未配置或不存在",
  "pathSegmentCount": 0
}
```

### 使用示例

```bash
curl -X POST http://localhost:5000/api/debug/sort \
  -H "Content-Type: application/json" \
  -d '{"parcelId": "PKG001", "targetChuteId": "CHUTE_A"}'
```

### 工作流程

1. 接收包裹ID和目标格口ID
2. 调用路径生成器（`ISwitchingPathGenerator`）生成 `SwitchingPath`
3. 调用执行器（`ISwitchingPathExecutor`）执行路径
4. 返回执行结果和实际落格ID

### 预配置的格口

当前默认配置包含以下格口映射：

- **CHUTE_A**: 需要经过摆轮D1（30度）和摆轮D2（45度）
- **CHUTE_B**: 需要经过摆轮D1（0度直行）
- **CHUTE_C**: 需要经过摆轮D1（90度）和摆轮D3（30度）

**注意**: 这些配置存储在 LiteDB 数据库中，可以通过配置管理 API 动态修改。

## 配置管理 API

系统提供了完整的 RESTful API 用于动态管理格口到摆轮的路由配置，支持热更新（无需重启）。

### 主要功能

- ✅ **动态配置管理**: 通过 API 添加、修改、删除格口配置
- ✅ **热更新支持**: 配置更改立即生效，无需重启应用
- ✅ **数据持久化**: 使用 LiteDB 存储配置数据
- ✅ **配置验证**: 自动验证配置的正确性和完整性

### API 端点

| 方法 | 端点 | 说明 |
|------|------|------|
| GET | `/api/config/routes` | 获取所有路由配置 |
| GET | `/api/config/routes/{chuteId}` | 获取指定格口配置 |
| POST | `/api/config/routes` | 创建新的路由配置 |
| PUT | `/api/config/routes/{chuteId}` | 更新路由配置（热更新） |
| DELETE | `/api/config/routes/{chuteId}` | 删除路由配置 |

### 快速示例

```bash
# 创建新格口配置
curl -X POST http://localhost:5000/api/config/routes \
  -H "Content-Type: application/json" \
  -d '{
    "chuteId": "CHUTE_D",
    "diverterConfigurations": [
      {"diverterId": "D2", "targetAngle": 45, "sequenceNumber": 1},
      {"diverterId": "D3", "targetAngle": 90, "sequenceNumber": 2}
    ],
    "isEnabled": true
  }'

# 立即使用新配置（无需重启）
curl -X POST http://localhost:5000/api/debug/sort \
  -H "Content-Type: application/json" \
  -d '{"parcelId": "PKG001", "targetChuteId": "CHUTE_D"}'
```

详细的 API 文档请参阅：[配置管理 API 文档](CONFIGURATION_API.md)

## 运行项目

```bash
cd ZakYip.WheelDiverterSorter.Host
dotnet run
```

默认监听端口：5000（HTTP）

## ⚠️ 当前风险与缺陷

### 🔴 高风险项（需尽快解决）

#### 1. 测试覆盖率严重不足
- **问题**：项目中几乎没有单元测试或集成测试（仅有性能基准测试）
- **风险**：代码重构或新增功能时易引入bug，质量无法保证
- **影响**：系统稳定性无保障，回归测试成本高，难以保证生产环境质量
- **建议**：立即建立测试体系，核心逻辑覆盖率目标>80%

#### 2. 多厂商硬件支持不足
- **问题**：仅支持雷赛（Leadshine）控制器，其他主流PLC厂商未支持
- **风险**：限制系统在不同硬件环境下的部署灵活性
- **影响**：无法在使用西门子、三菱、欧姆龙等PLC的现场部署
- **建议**：实现西门子/三菱/欧姆龙PLC驱动，建立驱动插件化架构

#### 3. 系统架构已确认
- **说明**：以下功能根据架构设计**不需要实现**
- **扫码触发**：❌ 不需要 - 使用IO传感器，不依赖条码
- **供包台接口**：❌ 不需要 - 与上游RuleEngine通信即可
- **包裹历史**：❌ 不需要 - 上游RuleEngine负责存储
- **数据报表**：❌ 不需要 - 报表由上游系统提供
- **影响**：✅ 系统定位明确，专注于分拣执行层
- **建议**：保持当前架构，专注核心功能

### 🟡 中风险项（影响运维和优化）

#### 4. 可观测性仍需增强
- **问题**：虽有性能指标收集和传感器监控，但缺少可视化仪表板和完整告警系统
- **风险**：生产环境问题难以快速发现和处理
- **影响**：运维困难，故障响应慢，MTTR（平均修复时间）高
- **建议**：集成Grafana仪表板、完善告警系统（钉钉/邮件/短信）

#### 5. 路径算法较简单
- **问题**：当前使用直接映射，不考虑设备状态和负载，无备份路径
- **风险**：无法处理设备故障、维护场景，缺少容错能力
- **影响**：设备故障时分拣中断，无法自动切换备用路径
- **建议**：实现基于拓扑图的路径搜索、动态路径重规划、多路径支持

#### 6. 性能优化未充分验证
- **问题**：虽有缓存和对象池优化，但缺少实际高负载场景验证
- **风险**：不确定系统在高并发场景（1000+包裹/分钟）下的表现
- **影响**：可能在生产环境出现性能瓶颈
- **建议**：进行压力测试和负载测试，验证目标吞吐量

#### 7. 静态TTL设置
- **问题**：所有路径段使用固定5000ms的TTL
- **风险**：无法适应不同距离的摆轮节点或不同速度的输送线
- **影响**：可能导致不必要的超时或资源浪费
- **建议**：根据摆轮位置和输送速度动态计算TTL

### 🟢 低风险项（改进项）

#### 8. 硬件DLL管理
- **问题**：雷赛LTDMC.dll等原生DLL需要手动部署
- **风险**：部署复杂度增加，容易遗漏或版本不匹配
- **影响**：部署失败率高，难以自动化
- **建议**：使用NuGet打包、DLL版本检查、Docker镜像预装

#### 9. Web管理界面缺失
#### 9. Web管理界面缺失
- **问题**：仅有API接口，缺少友好的Web管理界面
- **风险**：操作不便，学习成本高
- **影响**：运维人员使用体验差，培训成本高
- **建议**：开发Web管理界面，提供实时监控、配置管理

### 🆕 硬件相关风险跟踪

| 风险项 | 描述 | 影响 | 建议 | 状态 |
|-------|------|------|------|------|
| 硬件兼容性 | 不同型号PLC协议可能不同 | 驱动失效或功能异常 | 详细测试各型号，建立兼容性列表 | ⚠️ 需注意 |
| 驱动版本冲突 | 不同厂商DLL可能冲突 | 系统崩溃或行为异常 | 使用独立AppDomain或进程隔离 | ⚠️ 需注意 |
| 设备掉线 | 网络中断或设备断电 | 分拣中断，包裹堆积 | ✅ 已实现自动检测和告警 | ✅ 已解决 |
| 传感器故障 | 传感器硬件损坏或读取错误 | 无法检测包裹，分拣停滞 | ✅ 已实现健康监控和故障检测 | ✅ 已解决 |
| 指令延迟 | PLC响应慢或网络延迟高 | 分拣效率低或超时 | 优化通信协议，添加预读机制 | ⚠️ 需优化 |
| 传感器误触发 | 环境干扰或灵敏度过高 | 错误检测包裹 | ✅ 已实现去抖动机制 | ✅ 已解决 |
| 并发资源冲突 | 多包裹同时请求同一摆轮 | 分拣错误或效率降低 | ✅ 已实现资源锁和队列管理 | ✅ 已解决 |

## 技术栈

- **.NET 8.0**: 核心框架
- **ASP.NET Core Minimal API**: Web API框架
- **依赖注入（DI）**: 服务管理
- **LiteDB**: 配置数据存储
- **雷赛LTDMC**: 硬件控制器驱动

## 相关文档

- [系统配置管理指南](SYSTEM_CONFIG_GUIDE.md)
- [配置管理API文档](CONFIGURATION_API.md)
- [API使用教程](API_USAGE_GUIDE.md)
- [通信层集成文档](COMMUNICATION_INTEGRATION.md)
- [与规则引擎的关系文档](RELATIONSHIP_WITH_RULEENGINE.md)
- [硬件驱动文档](ZakYip.WheelDiverterSorter.Drivers/README.md)
- [测试文档](TESTING.md)

## 贡献指南

1. Fork本仓库
2. 创建特性分支 (`git checkout -b feature/AmazingFeature`)
3. 提交更改 (`git commit -m 'Add some AmazingFeature'`)
4. 推送到分支 (`git push origin feature/AmazingFeature`)
5. 创建Pull Request

---

**最后更新：2025-11-13**
